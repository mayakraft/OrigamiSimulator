/* Origami Simulator (c) Amanda Ghassaei, MIT License */(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self,e.OrigamiSimulator=t())})(this,function(){'use strict';var _=Math.sqrt,x=Math.abs,v=Math.PI;function e(t){return e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e(t)}function o(e,t){return r(e)||a(e,t)||s()}function r(e){if(Array.isArray(e))return e}function a(e,t){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)){var o=[],r=!0,a=!1,i=void 0;try{for(var s,n=e[Symbol.iterator]();!(r=(s=n.next()).done)&&(o.push(s.value),!(t&&o.length===t));r=!0);}catch(e){a=!0,i=e}finally{try{r||null==n["return"]||n["return"]()}finally{if(a)throw i}}return o}}function s(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function n(e){function t(e){g.reset(new V.Vector3(e,0,0))}function o(e){g.reset(new V.Vector3(0,e,0))}function r(e){g.reset(new V.Vector3(0,0,e))}function a(){g.reset(new V.Vector3(1,1,1))}function i(){_.zoom=7,_.fov=100,_.updateProjectionMatrix(),_.position.x=4,_.position.y=4,_.position.z=4,g&&a()}function s(){if(e.vrEnabled)return void e.vive.render();if(x.render(h,_),e.capturer){if("png"===e.capturer){var t=e.threeView.renderer.domElement;return t.toBlob(function(t){saveAs(t,"".concat(e.screenRecordFilename,".png"))},"image/png"),e.capturer=null,e.shouldScaleCanvas=!1,e.shouldAnimateFoldPercent=!1,void e.threeView.onWindowResize()}e.capturer.capture(x.domElement)}}function n(){return e.needsSync&&e.model.sync(),e.simNeedsSync&&e.model.syncSolver(),e.simulationRunning&&e.model.step(),e.vrEnabled?void s():void(g.update(),s())}function l(){if(e.vrEnabled)return void e.warn("Can't resize window when in VR mode.");_.aspect=P.innerWidth/P.innerHeight,_.updateProjectionMatrix();var t=1;e.shouldScaleCanvas&&(t=e.capturerScale),x.setSize(.5*(t*P.innerWidth),.5*(t*P.innerHeight)),g.handleResize()}function c(e){g.enabled=e,g.enableRotate=e}function u(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:e.backgroundColor;h.background.setStyle("#".concat(t))}function d(){x.setPixelRatio(P.devicePixelRatio),x.setSize(f.width,f.height),m.append(x.domElement),h.background=new V.Color(16777215),u(),h.add(p);var e=new V.DirectionalLight(16777215,.7);e.position.set(100,100,100),h.add(e);var t=new V.DirectionalLight(16777215,.6);t.position.set(0,-100,0),h.add(t);var o=new V.SpotLight(16777215,.3);o.position.set(0,100,200),h.add(o);var r=new V.AmbientLight(16777215,.2);h.add(r),h.add(_),i(),g=new A(_,x.domElement),g.rotateSpeed=4,g.zoomSpeed=15,g.noPan=!0,g.staticMoving=!0,g.dynamicDampingFactor=.3,g.minDistance=.1,g.maxDistance=30,x.shadowMap.enabled=!0,x.shadowMap.type=V.PCFSoftShadowMap,s(),e.castShadow=!0,e.shadow.mapSize.width=2048,e.shadow.mapSize.height=2048,e.shadow.camera.near=.5,e.shadow.camera.far=500}var g,m=e.parent||P.document.getElementsByTagName("body")[0],f=null==m?{x:0,y:0,width:320,height:240}:m.getBoundingClientRect(),h=new V.Scene,p=new V.Object3D,_=new V.PerspectiveCamera(60,f.width/f.height,.1,500),x=new V.WebGLRenderer({antialias:!0});return d(),{sceneAddModel:function(e){p.add(e)},onWindowResize:l,startAnimation:function(){console.log("starting animation"),x.setAnimationLoop(n)},startSimulation:function(){console.log("starting simulation"),e.simulationRunning=!0},pauseSimulation:function(){e.simulationRunning=!1,console.log("pausing simulation")},enableCameraRotate:c,scene:h,camera:_,renderer:x,modelWrapper:p,setCameraX:t,setCameraY:o,setCameraZ:r,setCameraIso:a,resetModel:function(){p.rotation.set(0,0,0)},resetCamera:i,setBackgroundColor:u}}function l(e,t,o){this.type="node",this.index=o,this.globals=e,this._originalPosition=t.clone(),this.beams=[],this.creases=[],this.invCreases=[],this.externalForce=null,this.fixed=!1}function c(t){function o(e){s&&e!=s&&(h.getObject3D().visible=!1),s=e,s&&(h.getObject3D().visible=!0)}function r(r){if(f&&(d=!0),"rotate"!==t.touchMode){if(!d){var e=t.parent||P.document.getElementsByTagName("body")[0],l=e.getBoundingClientRect();c.x=2*((r.clientX-l.x)/l.width)-1,c.y=2*-((r.clientY-l.y)/l.height)+1,n.setFromCamera(c,t.threeView.camera);var u=i(r,t.model.getMesh());o(u)}else if(s){var g=t.parent||P.document.getElementsByTagName("body")[0],m=g.getBoundingClientRect();c.x=2*((r.clientX-m.x)/m.width)-1,c.y=2*-((r.clientY-m.y)/m.height)+1,n.setFromCamera(c,t.threeView.camera);var p=a(s.getPosition().clone());s.moveManually(p),t.nodePositionHasChanged=!0}if(s){var _=s.getPosition();h.getObject3D().position.set(_.x,_.y,_.z)}}}function a(e){var o=t.threeView.camera.getWorldDirection(),r=e.dot(o);u.set(o,-r);var a=new N.Vector3;return n.ray.intersectPlane(u,a),a}function i(o,e){var r=null,a=n.intersectObjects(e,!1);if(0<a.length){var s=a[0].face,l=a[0].point,c=t.model.getPositionsArray(),u=[];u.push(new N.Vector3(c[3*s.a],c[3*s.a+1],c[3*s.a+2])),u.push(new N.Vector3(c[3*s.b],c[3*s.b+1],c[3*s.b+2])),u.push(new N.Vector3(c[3*s.c],c[3*s.c+1],c[3*s.c+2]));for(var d,g=u[0].clone().sub(l).lengthSq(),m=s.a,f=1;3>f;f+=1)d=u[f].clone().sub(l).lengthSq(),d<g&&(g=d,m=1===f?s.b:s.c);var h=t.model.getNodes();r=h[m]}return r}var s,n=new N.Raycaster,c=new N.Vector2,u=new N.Plane(new N.Vector3(0,0,1)),d=!1,g=null,m=!1,f=!1,h=new l(t,new N.Vector3());return h.setTransparent(),t.threeView.scene.add(h.getObject3D()),P.document.addEventListener("mousedown",function(r){if(f=!0,"grab"===t.touchMode){var e=t.parent||P.document.getElementsByTagName("body")[0],a=e.getBoundingClientRect();c.x=2*((r.clientX-a.x)/a.width)-1,c.y=2*-((r.clientY-a.y)/a.height)+1,n.setFromCamera(c,t.threeView.camera);var l=i(r,t.model.getMesh());o(l),s?(g=s,m=g.isFixed(),g.setFixed(!0),t.fixedHasChanged=!0,t.threeView.enableCameraRotate(!1)):t.threeView.enableCameraRotate(!0)}},!1),P.document.addEventListener("mouseup",function(){d=!1,g&&(g.setFixed(m),g=null,t.fixedHasChanged=!0,o(null),t.shouldCenterGeo=!0),"grab"===t.touchMode&&t.threeView.enableCameraRotate(!1),f=!1},!1),P.document.addEventListener("mousemove",r,!1),{hideHighlighters:function(){h.getObject3D().visible=!1}}}function u(){function e(e,t,o){var r=e.createShader(o);e.shaderSource(r,t),e.compileShader(r);var a=e.getShaderParameter(r,e.COMPILE_STATUS);if(!a)throw new Error("could not compile shader: ".concat(e.getShaderInfoLog(r)));return r}function t(e,t,o){var r=e.createProgram();e.attachShader(r,t),e.attachShader(r,o),e.linkProgram(r);var a=e.getProgramParameter(r,e.LINK_STATUS);if(!a)throw new Error("program filed to link: ".concat(e.getProgramInfoLog(r)));return r}function o(t,o,r){return e(t,o,r)}return{createProgramFromSource:function(e,r,a){var i=o(e,r,e.VERTEX_SHADER),s=o(e,a,e.FRAGMENT_SHADER);return t(e,i,s)},loadVertexData:function(e,t){e.bindBuffer(e.ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),e.STATIC_DRAW);var o=e.getAttribLocation(t,"a_position");e.enableVertexAttribArray(o),e.vertexAttribPointer(o,2,e.FLOAT,!1,0,0)},makeTexture:function(e,t,o,r,a){var i=e.createTexture();return e.bindTexture(e.TEXTURE_2D,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,o,0,e.RGBA,r,a),i}}}function d(){function e(){console.warn("floating point textures are not supported on your system")}function t(){this.reset()}var o=u(),r=P.document.createElement("canvas");r.setAttribute("style","display:none;"),r.setAttribute("class","gpuMathCanvas"),P.document.body.appendChild(r);var a=r.getContext("webgl",{antialias:!1})||r.getContext("experimental-webgl",{antialias:!1}),i=a.getExtension("OES_texture_float");i||e(),a.disable(a.DEPTH_TEST);var s=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);return console.log("".concat(s," textures max")),t.prototype.createProgram=function(e,t,r){var i=this.programs,s=i[e];return s?void a.useProgram(s.program):void(s=o.createProgramFromSource(a,t,r),a.useProgram(s),o.loadVertexData(a,s),i[e]={program:s,uniforms:{}})},t.prototype.initTextureFromData=function(e,t,r,i,s,n){var l=this.textures[e];if(l){if(!n)return void console.warn("already a texture with the name ".concat(e));a.deleteTexture(l)}l=o.makeTexture(a,t,r,a[i],s),this.textures[e]=l},t.prototype.initFrameBufferForTexture=function(t,o){var r=this.frameBuffers[t];if(r){if(!o)return void console.warn("framebuffer already exists for texture ".concat(t));a.deleteFramebuffer(r)}var i=this.textures[t];if(!i)return void console.warn("texture ".concat(t," does not exist"));r=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,r),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,i,0);var s=a.checkFramebufferStatus(a.FRAMEBUFFER);s!==a.FRAMEBUFFER_COMPLETE&&e(),this.frameBuffers[t]=r},t.prototype.setUniformForProgram=function(e,t,o,r){if(!this.programs[e])return void console.warn("no program with name "+e);var i=this.programs[e].uniforms,s=i[t];s||(s=a.getUniformLocation(this.programs[e].program,t),i[t]=s),"1f"===r?a.uniform1f(s,o):"2f"===r?a.uniform2f(s,o[0],o[1]):"3f"===r?a.uniform3f(s,o[0],o[1],o[2]):"1i"===r?a.uniform1i(s,o):console.warn("no uniform for type ".concat(r))},t.prototype.setSize=function(e,t){a.viewport(0,0,e,t),r.style.width="".concat(e,"px"),r.style.height="".concat(t,"px")},t.prototype.setProgram=function(e){var t=this.programs[e];t&&a.useProgram(t.program)},t.prototype.step=function(e,t,o,r){a.useProgram(this.programs[e].program),r&&this.setUniformForProgram(e,"u_time",r,"1f"),a.bindFramebuffer(a.FRAMEBUFFER,this.frameBuffers[o]);for(var s=0;s<t.length;s+=1)a.activeTexture(a.TEXTURE0+s),a.bindTexture(a.TEXTURE_2D,this.textures[t[s]]);a.drawArrays(a.TRIANGLE_STRIP,0,4)},t.prototype.swapTextures=function(e,t){var o=this.textures[e];this.textures[e]=this.textures[t],this.textures[t]=o,o=this.frameBuffers[e],this.frameBuffers[e]=this.frameBuffers[t],this.frameBuffers[t]=o},t.prototype.swap3Textures=function(e,t,o){var r=this.textures[o];this.textures[o]=this.textures[t],this.textures[t]=this.textures[e],this.textures[e]=r,r=this.frameBuffers[o],this.frameBuffers[o]=this.frameBuffers[t],this.frameBuffers[t]=this.frameBuffers[e],this.frameBuffers[e]=r},t.prototype.readyToRead=function(){return a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE},t.prototype.readPixels=function(e,t,o,r,i){a.readPixels(e,t,o,r,a.RGBA,a.UNSIGNED_BYTE,i)},t.prototype.reset=function(){this.programs={},this.frameBuffers={},this.textures={},this.index=0},new t}function g(e){function t(){var t=e.gpuMath;t.setProgram("normalCalc"),t.setSize(te,te),t.step("normalCalc",["u_faceVertexIndices","u_lastPosition","u_originalPosition"],"u_normals"),t.setProgram("thetaCalc"),t.setSize(oe,oe),t.step("thetaCalc",["u_normals","u_lastTheta","u_creaseVectors","u_lastPosition","u_originalPosition"],"u_theta"),t.setProgram("updateCreaseGeo"),t.step("updateCreaseGeo",["u_lastPosition","u_originalPosition","u_creaseMeta2"],"u_creaseGeo"),"verlet"===e.integrationType?(t.setProgram("positionCalcVerlet"),t.setSize(Q,Q),t.step("positionCalcVerlet",["u_lastPosition","u_lastLastPosition","u_lastVelocity","u_originalPosition","u_externalForces","u_mass","u_meta","u_beamMeta","u_creaseMeta","u_nodeCreaseMeta","u_normals","u_theta","u_creaseGeo","u_meta2","u_nodeFaceMeta","u_nominalTriangles"],"u_position"),t.step("velocityCalcVerlet",["u_position","u_lastPosition","u_mass"],"u_velocity"),t.swapTextures("u_lastPosition","u_lastLastPosition")):(t.setProgram("velocityCalc"),t.setSize(Q,Q),t.step("velocityCalc",["u_lastPosition","u_lastVelocity","u_originalPosition","u_externalForces","u_mass","u_meta","u_beamMeta","u_creaseMeta","u_nodeCreaseMeta","u_normals","u_theta","u_creaseGeo","u_meta2","u_nodeFaceMeta","u_nominalTriangles"],"u_velocity"),t.step("positionCalc",["u_velocity","u_lastPosition","u_mass"],"u_position")),t.swapTextures("u_theta","u_lastTheta"),t.swapTextures("u_velocity","u_lastVelocity"),t.swapTextures("u_position","u_lastPosition")}function o(){for(var e=0,t=0,o=0,r=0;r<D.length;r+=3)e+=D[r],t+=D[r+1],o+=D[r+2];var a=new L.Vector3(e,t,o);return a.multiplyScalar(3/D.length),a}function r(){var t=Math.ceil;if(e.gpuMath.setProgram("packToBytes"),e.gpuMath.setUniformForProgram("packToBytes","u_vectorLength",4,"1f"),e.gpuMath.setUniformForProgram("packToBytes","u_floatTextureDim",[Q,Q],"2f"),e.gpuMath.setSize(4*Q,Q),e.gpuMath.step("packToBytes",["u_lastPosition"],"outputBytes"),e.gpuMath.readyToRead()){var o=4*y.length,r=t(o/(4*Q)),a=new Uint8Array(4*(4*(r*Q)));e.gpuMath.readPixels(0,0,4*Q,r,a);for(var s=new Float32Array(a.buffer),n="axialStrain"===e.colorMode,l=0;l<y.length;l+=1){var c=4*l,u=100*s[c+3],d=new L.Vector3(s[c],s[c+1],s[c+2]);if(d.add(y[l]._originalPosition),D[3*l]=d.x,D[3*l+1]=d.y,D[3*l+2]=d.z,n){u>e.strainClip&&(u=e.strainClip);var g=.7*(1-u/e.strainClip),m=new L.Color;m.setHSL(g,1,.5),T[3*l]=m.r,T[3*l+1]=m.g,T[3*l+2]=m.b}}}else console.log("shouldn't be here")}function a(){var t=i();e.gpuMath.setProgram("thetaCalc"),e.gpuMath.setUniformForProgram("thetaCalc","u_dt",t,"1f"),e.gpuMath.setProgram("velocityCalc"),e.gpuMath.setUniformForProgram("velocityCalc","u_dt",t,"1f"),e.gpuMath.setProgram("positionCalcVerlet"),e.gpuMath.setUniformForProgram("positionCalcVerlet","u_dt",t,"1f"),e.gpuMath.setProgram("positionCalc"),e.gpuMath.setUniformForProgram("positionCalc","u_dt",t,"1f"),e.gpuMath.setProgram("velocityCalcVerlet"),e.gpuMath.setUniformForProgram("velocityCalcVerlet","u_dt",t,"1f")}function i(){var e=0;return C.forEach(function(t){t.getNaturalFrequency()>e&&(e=t.getNaturalFrequency())}),.9*(1/(2*v*e))}function s(t){t.initTextureFromData("u_position",Q,Q,"FLOAT",A,!0),t.initTextureFromData("u_lastPosition",Q,Q,"FLOAT",V,!0),t.initTextureFromData("u_lastLastPosition",Q,Q,"FLOAT",I,!0),t.initTextureFromData("u_velocity",Q,Q,"FLOAT",S,!0),t.initTextureFromData("u_lastVelocity",Q,Q,"FLOAT",E,!0),t.initTextureFromData("u_theta",oe,oe,"FLOAT",K,!0),t.initTextureFromData("u_lastTheta",oe,oe,"FLOAT",J,!0),t.initTextureFromData("u_normals",te,te,"FLOAT",O,!0),t.initFrameBufferForTexture("u_position",!0),t.initFrameBufferForTexture("u_lastPosition",!0),t.initFrameBufferForTexture("u_lastLastPosition",!0),t.initFrameBufferForTexture("u_velocity",!0),t.initFrameBufferForTexture("u_lastVelocity",!0),t.initFrameBufferForTexture("u_theta",!0),t.initFrameBufferForTexture("u_lastTheta",!0),t.initFrameBufferForTexture("u_normals",!0),t.initTextureFromData("u_meta",Q,Q,"FLOAT",N,!0),t.initTextureFromData("u_meta2",Q,Q,"FLOAT",w,!0),t.initTextureFromData("u_nominalTrinagles",te,te,"FLOAT",k,!0),t.initTextureFromData("u_nodeCreaseMeta",re,re,"FLOAT",q,!0),t.initTextureFromData("u_creaseMeta2",oe,oe,"FLOAT",X,!0),t.initTextureFromData("u_nodeFaceMeta",ae,ae,"FLOAT",G,!0),t.initTextureFromData("u_creaseGeo",oe,oe,"FLOAT",W,!0),t.initFrameBufferForTexture("u_creaseGeo",!0),t.initTextureFromData("u_faceVertexIndices",te,te,"FLOAT",R,!0),t.initTextureFromData("u_nominalTriangles",te,te,"FLOAT",k,!0),t.createProgram("positionCalc","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_textureDim;\nuniform float u_dt;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_velocity;\nuniform sampler2D u_mass;\n\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDim;\n\n  vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;\n\n  float isFixed = texture2D(u_mass, scaledFragCoord).y;\n  if (isFixed == 1.0){\n    gl_FragColor = vec4(lastPosition, 0.0);\n    return;\n  }\n\n  vec4 velocityData = texture2D(u_velocity, scaledFragCoord);\n  vec3 position = velocityData.xyz*u_dt + lastPosition;\n  gl_FragColor = vec4(position, velocityData.a);//velocity.a has error info\n}\n"),t.setUniformForProgram("positionCalc","u_velocity",0,"1i"),t.setUniformForProgram("positionCalc","u_lastPosition",1,"1i"),t.setUniformForProgram("positionCalc","u_mass",2,"1i"),t.setUniformForProgram("positionCalc","u_textureDim",[Q,Q],"2f"),t.createProgram("velocityCalcVerlet","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_textureDim;\nuniform float u_dt;\nuniform sampler2D u_position;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_mass;\n\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDim;\n\n  float isFixed = texture2D(u_mass, scaledFragCoord).y;\n  if (isFixed == 1.0){\n    gl_FragColor = vec4(0.0);\n    return;\n  }\n\n  vec3 position = texture2D(u_position, scaledFragCoord).xyz;\n  vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;\n  gl_FragColor = vec4((position-lastPosition)/u_dt,0.0);\n}\n"),t.setUniformForProgram("velocityCalcVerlet","u_position",0,"1i"),t.setUniformForProgram("velocityCalcVerlet","u_lastPosition",1,"1i"),t.setUniformForProgram("velocityCalcVerlet","u_mass",2,"1i"),t.setUniformForProgram("velocityCalcVerlet","u_textureDim",[Q,Q],"2f"),t.createProgram("velocityCalc","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_textureDim;\nuniform vec2 u_textureDimEdges;\nuniform vec2 u_textureDimFaces;\nuniform vec2 u_textureDimCreases;\nuniform vec2 u_textureDimNodeCreases;\nuniform vec2 u_textureDimNodeFaces;\nuniform float u_creasePercent;\nuniform float u_dt;\nuniform float u_axialStiffness;\nuniform float u_faceStiffness;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_lastVelocity;\nuniform sampler2D u_originalPosition;\nuniform sampler2D u_externalForces;\nuniform sampler2D u_mass;\nuniform sampler2D u_meta;//[beamsIndex, numBeam, nodeCreaseMetaIndex, numCreases]\nuniform sampler2D u_beamMeta;//[k, d, length, otherNodeIndex]\nuniform sampler2D u_creaseMeta;//[k, d, targetTheta]\nuniform sampler2D u_nodeCreaseMeta;//[creaseIndex, nodeIndex, -, -]\nuniform sampler2D u_normals;\nuniform sampler2D u_theta;//[theta, z, normal1Index, normal2Index]\nuniform sampler2D u_creaseGeo;//[h1, h2, coef1, coef2]\nuniform sampler2D u_meta2;//[nodesFaceIndex, numFaces]\nuniform sampler2D u_nodeFaceMeta;//[faceIndex, a, b, c]\nuniform sampler2D u_nominalTriangles;//[angleA, angleB, angleC]\nuniform bool u_calcFaceStrain;\n\nvec4 getFromArray(float index1D, vec2 dimensions, sampler2D tex){\n  vec2 index = vec2(mod(index1D, dimensions.x)+0.5, floor(index1D/dimensions.x)+0.5);\n  vec2 scaledIndex = index/dimensions;\n  return texture2D(tex, scaledIndex);\n}\n\nvec3 getPosition(float index1D){\n  vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);\n  vec2 scaledIndex = index/u_textureDim;\n  return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;\n}\n\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDim;\n\n  vec2 mass = texture2D(u_mass, scaledFragCoord).xy;\n  if (mass[1] == 1.0){//fixed\n    gl_FragColor = vec4(0.0);\n    return;\n  }\n  vec3 force = texture2D(u_externalForces, scaledFragCoord).xyz;\n  vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;\n  vec3 lastVelocity = texture2D(u_lastVelocity, scaledFragCoord).xyz;\n  vec3 originalPosition = texture2D(u_originalPosition, scaledFragCoord).xyz;\n\n  vec4 neighborIndices = texture2D(u_meta, scaledFragCoord);\n  vec4 meta = texture2D(u_meta, scaledFragCoord);\n  vec2 meta2 = texture2D(u_meta2, scaledFragCoord).xy;\n\n  float nodeError = 0.0;\n\n  for (int j=0;j<100;j++){//for all beams (up to 100, had to put a const int in here)\n    if (j >= int(meta[1])) break;\n\n    vec4 beamMeta = getFromArray(meta[0]+float(j), u_textureDimEdges, u_beamMeta);\n\n    float neighborIndex1D = beamMeta[3];\n    vec2 neighborIndex = vec2(mod(neighborIndex1D, u_textureDim.x)+0.5, floor(neighborIndex1D/u_textureDim.x)+0.5);\n    vec2 scaledNeighborIndex = neighborIndex/u_textureDim;\n    vec3 neighborLastPosition = texture2D(u_lastPosition, scaledNeighborIndex).xyz;\n    vec3 neighborLastVelocity = texture2D(u_lastVelocity, scaledNeighborIndex).xyz;\n    vec3 neighborOriginalPosition = texture2D(u_originalPosition, scaledNeighborIndex).xyz;\n\n    vec3 nominalDist = neighborOriginalPosition-originalPosition;\n    vec3 deltaP = neighborLastPosition-lastPosition+nominalDist;\n    float deltaPLength = length(deltaP);\n    deltaP -= deltaP*(beamMeta[2]/deltaPLength);\n    if (!u_calcFaceStrain) nodeError += abs(deltaPLength/length(nominalDist) - 1.0);\n    vec3 deltaV = neighborLastVelocity-lastVelocity;\n\n    vec3 _force = deltaP*beamMeta[0] + deltaV*beamMeta[1];\n    force += _force;\n  }\n  if (!u_calcFaceStrain) nodeError /= meta[1];\n\n  for (int j=0;j<100;j++){//for all creases (up to 100, had to put a const int in here)\n    if (j >= int(meta[3])) break;\n\n    vec4 nodeCreaseMeta = getFromArray(meta[2]+float(j), u_textureDimNodeCreases, u_nodeCreaseMeta);\n\n    float creaseIndex1D = nodeCreaseMeta[0];\n    vec2 creaseIndex = vec2(mod(creaseIndex1D, u_textureDimCreases.x)+0.5, floor(creaseIndex1D/u_textureDimCreases.x)+0.5);\n    vec2 scaledCreaseIndex = creaseIndex/u_textureDimCreases;\n\n    vec4 thetas = texture2D(u_theta, scaledCreaseIndex);\n    vec3 creaseMeta = texture2D(u_creaseMeta, scaledCreaseIndex).xyz;//[k, d, targetTheta]\n    vec4 creaseGeo = texture2D(u_creaseGeo, scaledCreaseIndex);//[h1, h2, coef1, coef2]\n    if (creaseGeo[0]< 0.0) continue;//crease disabled bc it has collapsed too much\n\n    float targetTheta = creaseMeta[2] * u_creasePercent;\n    float angForce = creaseMeta[0]*(targetTheta-thetas[0]);// + creaseMeta[1]*thetas[1];\n\n    float nodeNum = nodeCreaseMeta[1];//1, 2, 3, 4\n\n    if (nodeNum > 2.0){//crease reaction, node is on a crease\n\n      //node #1\n      vec3 normal1 = getFromArray(thetas[2], u_textureDimFaces, u_normals).xyz;\n\n      //node #2\n      vec3 normal2 = getFromArray(thetas[3], u_textureDimFaces, u_normals).xyz;\n\n      float coef1 = creaseGeo[2];\n      float coef2 = creaseGeo[3];\n\n      if (nodeNum == 3.0){\n        coef1 = 1.0-coef1;\n        coef2 = 1.0-coef2;\n      }\n\n      vec3 _force = -angForce*(coef1/creaseGeo[0]*normal1 + coef2/creaseGeo[1]*normal2);\n      force += _force;\n\n    } else {\n\n      float normalIndex1D = thetas[2];//node #1\n      float momentArm = creaseGeo[0];//node #1\n      if (nodeNum == 2.0) {\n        normalIndex1D = thetas[3];//node #2\n        momentArm = creaseGeo[1];//node #2\n      }\n\n      vec3 normal = getFromArray(normalIndex1D, u_textureDimFaces, u_normals).xyz;\n\n      vec3 _force = angForce/momentArm*normal;\n      force += _force;\n    }\n  }\n\n  for (int j=0;j<100;j++){//for all faces (up to 100, had to put a const int in here)\n    if (j >= int(meta2[1])) break;\n\n    vec4 faceMeta = getFromArray(meta2[0]+float(j), u_textureDimNodeFaces, u_nodeFaceMeta);//[face index, a, b, c]\n    vec3 nominalAngles = getFromArray(faceMeta[0], u_textureDimFaces, u_nominalTriangles).xyz;//[angA, angB, angC]\n\n    int faceIndex = 0;\n    if (faceMeta[2] < 0.0) faceIndex = 1;\n    if (faceMeta[3] < 0.0) faceIndex = 2;\n\n    //get node positions\n    vec3 a = faceIndex == 0 ? lastPosition+originalPosition : getPosition(faceMeta[1]);\n    vec3 b = faceIndex == 1 ? lastPosition+originalPosition : getPosition(faceMeta[2]);\n    vec3 c = faceIndex == 2 ? lastPosition+originalPosition : getPosition(faceMeta[3]);\n\n    //calc angles\n    vec3 ab = b-a;\n    vec3 ac = c-a;\n    vec3 bc = c-b;\n\n    float lengthAB = length(ab);\n    float lengthAC = length(ac);\n    float lengthBC = length(bc);\n\n    float tol = 0.0000001;\n    if (abs(lengthAB) < tol || abs(lengthBC) < tol || abs(lengthAC) < tol) continue;\n\n    ab /= lengthAB;\n    ac /= lengthAC;\n    bc /= lengthBC;\n\n    vec3 angles = vec3(acos(dot(ab, ac)),\n      acos(-1.0*dot(ab, bc)),\n      acos(dot(ac, bc)));\n    vec3 anglesDiff = nominalAngles-angles;\n\n    vec3 normal = getFromArray(faceMeta[0], u_textureDimFaces, u_normals).xyz;\n\n    //calc forces\n    anglesDiff *= u_faceStiffness;\n    if (faceIndex == 0){//a\n      vec3 normalCrossAC = cross(normal, ac)/lengthAC;\n      vec3 normalCrossAB = cross(normal, ab)/lengthAB;\n      force -= anglesDiff[0]*(normalCrossAC - normalCrossAB);\n      if (u_calcFaceStrain) nodeError += abs((nominalAngles[0]-angles[0])/nominalAngles[0]);\n      force -= anglesDiff[1]*normalCrossAB;\n      force += anglesDiff[2]*normalCrossAC;\n    } else if (faceIndex == 1){\n      vec3 normalCrossAB = cross(normal, ab)/lengthAB;\n      vec3 normalCrossBC = cross(normal, bc)/lengthBC;\n      force -= anglesDiff[0]*normalCrossAB;\n      force += anglesDiff[1]*(normalCrossAB + normalCrossBC);\n      if (u_calcFaceStrain) nodeError += abs((nominalAngles[1]-angles[1])/nominalAngles[1]);\n      force -= anglesDiff[2]*normalCrossBC;\n    } else if (faceIndex == 2){\n      vec3 normalCrossAC = cross(normal, ac)/lengthAC;\n      vec3 normalCrossBC = cross(normal, bc)/lengthBC;\n      force += anglesDiff[0]*normalCrossAC;\n      force -= anglesDiff[1]*normalCrossBC;\n      force += anglesDiff[2]*(normalCrossBC - normalCrossAC);\n      if (u_calcFaceStrain) nodeError += abs((nominalAngles[2]-angles[2])/nominalAngles[2]);\n    }\n\n  }\n  if (u_calcFaceStrain) nodeError /= meta2[1];\n\n  vec3 velocity = force*u_dt/mass[0] + lastVelocity;\n  gl_FragColor = vec4(velocity,nodeError);\n}\n"),t.setUniformForProgram("velocityCalc","u_lastPosition",0,"1i"),t.setUniformForProgram("velocityCalc","u_lastVelocity",1,"1i"),t.setUniformForProgram("velocityCalc","u_originalPosition",2,"1i"),t.setUniformForProgram("velocityCalc","u_externalForces",3,"1i"),t.setUniformForProgram("velocityCalc","u_mass",4,"1i"),t.setUniformForProgram("velocityCalc","u_meta",5,"1i"),t.setUniformForProgram("velocityCalc","u_beamMeta",6,"1i"),t.setUniformForProgram("velocityCalc","u_creaseMeta",7,"1i"),t.setUniformForProgram("velocityCalc","u_nodeCreaseMeta",8,"1i"),t.setUniformForProgram("velocityCalc","u_normals",9,"1i"),t.setUniformForProgram("velocityCalc","u_theta",10,"1i"),t.setUniformForProgram("velocityCalc","u_creaseGeo",11,"1i"),t.setUniformForProgram("velocityCalc","u_meta2",12,"1i"),t.setUniformForProgram("velocityCalc","u_nodeFaceMeta",13,"1i"),t.setUniformForProgram("velocityCalc","u_nominalTriangles",14,"1i"),t.setUniformForProgram("velocityCalc","u_textureDim",[Q,Q],"2f"),t.setUniformForProgram("velocityCalc","u_textureDimEdges",[ee,ee],"2f"),t.setUniformForProgram("velocityCalc","u_textureDimFaces",[te,te],"2f"),t.setUniformForProgram("velocityCalc","u_textureDimCreases",[oe,oe],"2f"),t.setUniformForProgram("velocityCalc","u_textureDimNodeCreases",[re,re],"2f"),t.setUniformForProgram("velocityCalc","u_textureDimNodeFaces",[ae,ae],"2f"),t.setUniformForProgram("velocityCalc","u_creasePercent",e.creasePercent,"1f"),t.setUniformForProgram("velocityCalc","u_axialStiffness",e.axialStiffness,"1f"),t.setUniformForProgram("velocityCalc","u_faceStiffness",e.faceStiffness,"1f"),t.setUniformForProgram("velocityCalc","u_calcFaceStrain",e.calcFaceStrain,"1f"),t.createProgram("positionCalcVerlet","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_textureDim;\nuniform vec2 u_textureDimEdges;\nuniform vec2 u_textureDimFaces;\nuniform vec2 u_textureDimCreases;\nuniform vec2 u_textureDimNodeCreases;\nuniform vec2 u_textureDimNodeFaces;\nuniform float u_creasePercent;\nuniform float u_dt;\nuniform float u_axialStiffness;\nuniform float u_faceStiffness;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_lastLastPosition;\nuniform sampler2D u_lastVelocity;\nuniform sampler2D u_originalPosition;\nuniform sampler2D u_externalForces;\nuniform sampler2D u_mass;\nuniform sampler2D u_meta;//[beamsIndex, numBeam, nodeCreaseMetaIndex, numCreases]\nuniform sampler2D u_beamMeta;//[k, d, length, otherNodeIndex]\nuniform sampler2D u_creaseMeta;//[k, d, targetTheta]\nuniform sampler2D u_nodeCreaseMeta;//[creaseIndex, nodeIndex, -, -]\nuniform sampler2D u_normals;\nuniform sampler2D u_theta;//[theta, z, normal1Index, normal2Index]\nuniform sampler2D u_creaseGeo;//[h1, h2, coef1, coef2]\nuniform sampler2D u_meta2;//[nodesFaceIndex, numFaces]\nuniform sampler2D u_nodeFaceMeta;//[faceIndex, a, b, c]\nuniform sampler2D u_nominalTriangles;//[angleA, angleB, angleC]\n\nvec4 getFromArray(float index1D, vec2 dimensions, sampler2D tex){\n  vec2 index = vec2(mod(index1D, dimensions.x)+0.5, floor(index1D/dimensions.x)+0.5);\n  vec2 scaledIndex = index/dimensions;\n  return texture2D(tex, scaledIndex);\n}\n\nvec3 getPosition(float index1D){\n  vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);\n  vec2 scaledIndex = index/u_textureDim;\n  return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;\n}\n\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDim;\n\n  vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;\n\n  vec2 mass = texture2D(u_mass, scaledFragCoord).xy;\n  if (mass[1] == 1.0){//fixed\n    gl_FragColor = vec4(lastPosition, 0.0);\n    return;\n  }\n  vec3 force = texture2D(u_externalForces, scaledFragCoord).xyz;\n  vec3 lastLastPosition = texture2D(u_lastLastPosition, scaledFragCoord).xyz;\n  vec3 lastVelocity = texture2D(u_lastVelocity, scaledFragCoord).xyz;\n  vec3 originalPosition = texture2D(u_originalPosition, scaledFragCoord).xyz;\n\n  vec4 neighborIndices = texture2D(u_meta, scaledFragCoord);\n  vec4 meta = texture2D(u_meta, scaledFragCoord);\n  vec2 meta2 = texture2D(u_meta2, scaledFragCoord).xy;\n\n  float nodeError = 0.0;\n\n  for (int j=0;j<100;j++){//for all beams (up to 100, had to put a const int in here)\n    if (j >= int(meta[1])) break;\n\n    vec4 beamMeta = getFromArray(meta[0]+float(j), u_textureDimEdges, u_beamMeta);\n\n    float neighborIndex1D = beamMeta[3];\n    vec2 neighborIndex = vec2(mod(neighborIndex1D, u_textureDim.x)+0.5, floor(neighborIndex1D/u_textureDim.x)+0.5);\n    vec2 scaledNeighborIndex = neighborIndex/u_textureDim;\n    vec3 neighborLastPosition = texture2D(u_lastPosition, scaledNeighborIndex).xyz;\n    vec3 neighborLastVelocity = texture2D(u_lastVelocity, scaledNeighborIndex).xyz;\n    vec3 neighborOriginalPosition = texture2D(u_originalPosition, scaledNeighborIndex).xyz;\n\n    vec3 deltaP = neighborLastPosition+neighborOriginalPosition-lastPosition-originalPosition;\n    float deltaPLength = length(deltaP);\n    float nominalLength = beamMeta[2];\n    deltaP *= (1.0-nominalLength/deltaPLength);\n    nodeError += abs(deltaPLength/nominalLength - 1.0);\n    vec3 deltaV = neighborLastVelocity-lastVelocity;\n\n    vec3 _force = deltaP*beamMeta[0] + deltaV*beamMeta[1];\n    force += _force;\n  }\n  nodeError /= meta[1];\n\n  for (int j=0;j<100;j++){//for all creases (up to 100, had to put a const int in here)\n    if (j >= int(meta[3])) break;\n\n    vec4 nodeCreaseMeta = getFromArray(meta[2]+float(j), u_textureDimNodeCreases, u_nodeCreaseMeta);\n\n    float creaseIndex1D = nodeCreaseMeta[0];\n    vec2 creaseIndex = vec2(mod(creaseIndex1D, u_textureDimCreases.x)+0.5, floor(creaseIndex1D/u_textureDimCreases.x)+0.5);\n    vec2 scaledCreaseIndex = creaseIndex/u_textureDimCreases;\n\n    vec4 thetas = texture2D(u_theta, scaledCreaseIndex);\n    vec3 creaseMeta = texture2D(u_creaseMeta, scaledCreaseIndex).xyz;//[k, d, targetTheta]\n    vec4 creaseGeo = texture2D(u_creaseGeo, scaledCreaseIndex);//[h1, h2, coef1, coef2]\n    if (creaseGeo[0]< 0.0) continue;//crease disabled bc it has collapsed too much\n\n    float targetTheta = creaseMeta[2] * u_creasePercent;\n    float angForce = creaseMeta[0]*(targetTheta-thetas[0]);// + creaseMeta[1]*thetas[1];\n\n    float nodeNum = nodeCreaseMeta[1];//1, 2, 3, 4\n\n    if (nodeNum > 2.0){//crease reaction, node is on a crease\n\n      //node #1\n      vec3 normal1 = getFromArray(thetas[2], u_textureDimFaces, u_normals).xyz;\n\n      //node #2\n      vec3 normal2 = getFromArray(thetas[3], u_textureDimFaces, u_normals).xyz;\n\n      float coef1 = creaseGeo[2];\n      float coef2 = creaseGeo[3];\n\n      if (nodeNum == 3.0){\n        coef1 = 1.0-coef1;\n        coef2 = 1.0-coef2;\n      }\n\n      vec3 _force = -angForce*(coef1/creaseGeo[0]*normal1 + coef2/creaseGeo[1]*normal2);\n      force += _force;\n\n    } else {\n\n      float normalIndex1D = thetas[2];//node #1\n      float momentArm = creaseGeo[0];//node #1\n      if (nodeNum == 2.0) {\n        normalIndex1D = thetas[3];//node #2\n        momentArm = creaseGeo[1];//node #2\n      }\n\n      vec3 normal = getFromArray(normalIndex1D, u_textureDimFaces, u_normals).xyz;\n\n      vec3 _force = angForce/momentArm*normal;\n      force += _force;\n    }\n  }\n\n  for (int j=0;j<100;j++){//for all faces (up to 100, had to put a const int in here)\n    if (j >= int(meta2[1])) break;\n\n    vec4 faceMeta = getFromArray(meta2[0]+float(j), u_textureDimNodeFaces, u_nodeFaceMeta);//[face index, a, b, c]\n    vec3 nominalAngles = getFromArray(faceMeta[0], u_textureDimFaces, u_nominalTriangles).xyz;//[angA, angB, angC]\n\n    int faceIndex = 0;\n    if (faceMeta[2] < 0.0) faceIndex = 1;\n    if (faceMeta[3] < 0.0) faceIndex = 2;\n\n    //get node positions\n    vec3 a = faceIndex == 0 ? lastPosition+originalPosition : getPosition(faceMeta[1]);\n    vec3 b = faceIndex == 1 ? lastPosition+originalPosition : getPosition(faceMeta[2]);\n    vec3 c = faceIndex == 2 ? lastPosition+originalPosition : getPosition(faceMeta[3]);\n\n    //calc angles\n    vec3 ab = b-a;\n    vec3 ac = c-a;\n    vec3 bc = c-b;\n\n    float lengthAB = length(ab);\n    float lengthAC = length(ac);\n    float lengthBC = length(bc);\n\n    float tol = 0.0000001;\n    if (abs(lengthAB) < tol || abs(lengthBC) < tol || abs(lengthAC) < tol) continue;\n\n    ab /= lengthAB;\n    ac /= lengthAC;\n    bc /= lengthBC;\n\n    vec3 angles = vec3(acos(dot(ab, ac)),\n      acos(-1.0*dot(ab, bc)),\n      acos(dot(ac, bc)));\n    vec3 anglesDiff = nominalAngles-angles;\n\n    vec3 normal = getFromArray(faceMeta[0], u_textureDimFaces, u_normals).xyz;\n\n    //calc forces\n    anglesDiff *= u_faceStiffness;\n    if (faceIndex == 0){//a\n      vec3 normalCrossAC = cross(normal, ac)/lengthAC;\n      vec3 normalCrossAB = cross(normal, ab)/lengthAB;\n      force -= anglesDiff[0]*(normalCrossAC - normalCrossAB);\n      force -= anglesDiff[1]*normalCrossAB;\n      force += anglesDiff[2]*normalCrossAC;\n    } else if (faceIndex == 1){\n      vec3 normalCrossAB = cross(normal, ab)/lengthAB;\n      vec3 normalCrossBC = cross(normal, bc)/lengthBC;\n      force -= anglesDiff[0]*normalCrossAB;\n      force += anglesDiff[1]*(normalCrossAB + normalCrossBC);\n      force -= anglesDiff[2]*normalCrossBC;\n    } else if (faceIndex == 2){\n      vec3 normalCrossAC = cross(normal, ac)/lengthAC;\n      vec3 normalCrossBC = cross(normal, bc)/lengthBC;\n      force += anglesDiff[0]*normalCrossAC;\n      force -= anglesDiff[1]*normalCrossBC;\n      force += anglesDiff[2]*(normalCrossBC - normalCrossAC);\n    }\n\n  }\n\n  vec3 nextPosition = force*u_dt*u_dt/mass[0] + 2.0*lastPosition - lastLastPosition;\n  gl_FragColor = vec4(nextPosition,nodeError);//position.a has error info\n}\n"),t.setUniformForProgram("positionCalcVerlet","u_lastPosition",0,"1i"),t.setUniformForProgram("positionCalcVerlet","u_lastLastPosition",1,"1i"),t.setUniformForProgram("positionCalcVerlet","u_lastVelocity",2,"1i"),t.setUniformForProgram("positionCalcVerlet","u_originalPosition",3,"1i"),t.setUniformForProgram("positionCalcVerlet","u_externalForces",4,"1i"),t.setUniformForProgram("positionCalcVerlet","u_mass",5,"1i"),t.setUniformForProgram("positionCalcVerlet","u_meta",6,"1i"),t.setUniformForProgram("positionCalcVerlet","u_beamMeta",7,"1i"),t.setUniformForProgram("positionCalcVerlet","u_creaseMeta",8,"1i"),t.setUniformForProgram("positionCalcVerlet","u_nodeCreaseMeta",9,"1i"),t.setUniformForProgram("positionCalcVerlet","u_normals",10,"1i"),t.setUniformForProgram("positionCalcVerlet","u_theta",11,"1i"),t.setUniformForProgram("positionCalcVerlet","u_creaseGeo",12,"1i"),t.setUniformForProgram("positionCalcVerlet","u_meta2",13,"1i"),t.setUniformForProgram("positionCalcVerlet","u_nodeFaceMeta",14,"1i"),t.setUniformForProgram("positionCalcVerlet","u_nominalTriangles",15,"1i"),t.setUniformForProgram("positionCalcVerlet","u_textureDim",[Q,Q],"2f"),t.setUniformForProgram("positionCalcVerlet","u_textureDimEdges",[ee,ee],"2f"),t.setUniformForProgram("positionCalcVerlet","u_textureDimFaces",[te,te],"2f"),t.setUniformForProgram("positionCalcVerlet","u_textureDimCreases",[oe,oe],"2f"),t.setUniformForProgram("positionCalcVerlet","u_textureDimNodeCreases",[re,re],"2f"),t.setUniformForProgram("positionCalcVerlet","u_textureDimNodeFaces",[ae,ae],"2f"),t.setUniformForProgram("positionCalcVerlet","u_creasePercent",e.creasePercent,"1f"),t.setUniformForProgram("positionCalcVerlet","u_axialStiffness",e.axialStiffness,"1f"),t.setUniformForProgram("positionCalcVerlet","u_faceStiffness",e.faceStiffness,"1f"),t.setUniformForProgram("positionCalcVerlet","u_calcFaceStrain",e.calcFaceStrain,"1f"),t.createProgram("thetaCalc","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","#define TWO_PI 6.283185307179586476925286766559\nprecision mediump float;\nuniform vec2 u_textureDim;\nuniform vec2 u_textureDimFaces;\nuniform vec2 u_textureDimCreases;\nuniform sampler2D u_normals;\nuniform sampler2D u_lastTheta;\nuniform sampler2D u_creaseVectors;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_originalPosition;\nuniform float u_dt;\n\nvec4 getFromArray(float index1D, vec2 dimensions, sampler2D tex){\n  vec2 index = vec2(mod(index1D, dimensions.x)+0.5, floor(index1D/dimensions.x)+0.5);\n  vec2 scaledIndex = index/dimensions;\n  return texture2D(tex, scaledIndex);\n}\n\nvoid main(){\n\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDimCreases;\n\n  vec4 lastTheta = texture2D(u_lastTheta, scaledFragCoord);\n\n  if (lastTheta[2]<0.0){\n    gl_FragColor = vec4(lastTheta[0], 0.0, -1.0, -1.0);\n    return;\n  }\n\n  vec3 normal1 = getFromArray(lastTheta[2], u_textureDimFaces, u_normals).xyz;\n  vec3 normal2 = getFromArray(lastTheta[3], u_textureDimFaces, u_normals).xyz;\n\n  float dotNormals = dot(normal1, normal2);//normals are already normalized, no need to divide by length\n  if (dotNormals < -1.0) dotNormals = -1.0;\n  else if (dotNormals > 1.0) dotNormals = 1.0;\n\n  vec2 creaseVectorIndices = texture2D(u_creaseVectors, scaledFragCoord).xy;\n  vec2 creaseNodeIndex = vec2(mod(creaseVectorIndices[0], u_textureDim.x)+0.5, floor(creaseVectorIndices[0]/u_textureDim.x)+0.5);\n  vec2 scaledNodeIndex = creaseNodeIndex/u_textureDim;\n  vec3 node0 = texture2D(u_lastPosition, scaledNodeIndex).xyz + texture2D(u_originalPosition, scaledNodeIndex).xyz;\n  creaseNodeIndex = vec2(mod(creaseVectorIndices[1], u_textureDim.x)+0.5, floor(creaseVectorIndices[1]/u_textureDim.x)+0.5);\n  scaledNodeIndex = creaseNodeIndex/u_textureDim;\n  vec3 node1 = texture2D(u_lastPosition, scaledNodeIndex).xyz + texture2D(u_originalPosition, scaledNodeIndex).xyz;\n\n  //https://math.stackexchange.com/questions/47059/how-do-i-calculate-a-dihedral-angle-given-cartesian-coordinates\n  vec3 creaseVector = normalize(node1-node0);\n  float x = dotNormals;\n  float y = dot(cross(normal1, creaseVector), normal2);\n\n  float theta = atan(y, x);\n\n  float diff = theta-lastTheta[0];\n  float origDiff = diff;\n  if (diff < -5.0) {\n    diff += TWO_PI;\n  } else if (diff > 5.0) {\n    diff -= TWO_PI;\n  }\n  theta = lastTheta[0] + diff;\n  gl_FragColor = vec4(theta, diff, lastTheta[2], lastTheta[3]);//[theta, w, normal1Index, normal2Index]\n}\n"),t.setUniformForProgram("thetaCalc","u_normals",0,"1i"),t.setUniformForProgram("thetaCalc","u_lastTheta",1,"1i"),t.setUniformForProgram("thetaCalc","u_creaseVectors",2,"1i"),t.setUniformForProgram("thetaCalc","u_lastPosition",3,"1i"),t.setUniformForProgram("thetaCalc","u_originalPosition",4,"1i"),t.setUniformForProgram("thetaCalc","u_textureDim",[Q,Q],"2f"),t.setUniformForProgram("thetaCalc","u_textureDimFaces",[te,te],"2f"),t.setUniformForProgram("thetaCalc","u_textureDimCreases",[oe,oe],"2f"),t.createProgram("normalCalc","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_textureDim;\nuniform vec2 u_textureDimFaces;\nuniform sampler2D u_faceVertexIndices;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_originalPosition;\n\nvec3 getPosition(float index1D){\n  vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);\n  vec2 scaledIndex = index/u_textureDim;\n  return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;\n}\n\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDimFaces;\n\n  vec3 indices = texture2D(u_faceVertexIndices, scaledFragCoord).xyz;\n\n  vec3 a = getPosition(indices[0]);\n  vec3 b = getPosition(indices[1]);\n  vec3 c = getPosition(indices[2]);\n\n  vec3 normal = normalize(cross(b-a, c-a));\n\n  gl_FragColor = vec4(normal, 0.0);\n}\n"),t.setUniformForProgram("normalCalc","u_faceVertexIndices",0,"1i"),t.setUniformForProgram("normalCalc","u_lastPosition",1,"1i"),t.setUniformForProgram("normalCalc","u_originalPosition",2,"1i"),t.setUniformForProgram("normalCalc","u_textureDim",[Q,Q],"2f"),t.setUniformForProgram("normalCalc","u_textureDimFaces",[te,te],"2f"),t.createProgram("packToBytes","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_floatTextureDim;\nuniform sampler2D u_floatTexture;\nuniform float u_vectorLength;\nfloat shift_right (float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\nfloat shift_left (float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\nfloat mask_last (float v, float bits) {\n  return mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits (float num, float from, float to) {\n  from = floor(from + 0.5); to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\nvec4 encode_float (float val) {\n  if (val == 0.0) return vec4(0, 0, 0, 0);\n  float sign = val > 0.0 ? 0.0 : 1.0;\n  val = abs(val);\n  float exponent = floor(log2(val));\n  float biased_exponent = exponent + 127.0;\n  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\n  float t = biased_exponent / 2.0;\n  float last_bit_of_biased_exponent = fract(t) * 2.0;\n  float remaining_bits_of_biased_exponent = floor(t);\n  float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\n  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\n  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\n  float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\n  return vec4(byte4, byte3, byte2, byte1);\n}\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  float textureXcoord = floor((fragCoord.x - 0.5)/u_vectorLength+0.0001) + 0.5;\n  vec4 data = texture2D(u_floatTexture, vec2(textureXcoord, fragCoord.y)/u_floatTextureDim);\n  int textureIndex = int(floor(mod(fragCoord.x-0.5+0.0001, u_vectorLength)));\n  if (textureIndex == 0) gl_FragColor = encode_float(data[0]);\n  else if (textureIndex == 1) gl_FragColor = encode_float(data[1]);\n  else if (textureIndex == 2) gl_FragColor = encode_float(data[2]);\n  else if (textureIndex == 3) gl_FragColor = encode_float(data[3]);\n}\n"),t.initTextureFromData("outputBytes",4*Q,Q,"UNSIGNED_BYTE",null,!0),t.initFrameBufferForTexture("outputBytes",!0),t.setUniformForProgram("packToBytes","u_floatTextureDim",[Q,Q],"2f"),t.setUniformForProgram("packToBytes","u_floatTexture",0,"1i"),t.createProgram("zeroTexture","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nvoid main(){\n  gl_FragColor = vec4(0.0);\n}\n"),t.createProgram("zeroThetaTexture","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform sampler2D u_theta;\nuniform vec2 u_textureDimCreases;\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDimCreases;\n  vec4 theta = texture2D(u_theta, scaledFragCoord);\n  gl_FragColor = vec4(0.0, 0.0, theta[2], theta[3]);\n}\n"),t.setUniformForProgram("zeroThetaTexture","u_theta",0,"1i"),t.setUniformForProgram("zeroThetaTexture","u_textureDimCreases",[oe,oe],"2f"),t.createProgram("centerTexture","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform sampler2D u_lastPosition;\nuniform vec2 u_textureDim;\nuniform vec3 u_center;\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDim;\n  vec3 position = texture2D(u_lastPosition, scaledFragCoord).xyz;\n  gl_FragColor = vec4(position-u_center, 0.0);\n}\n"),t.setUniformForProgram("centerTexture","u_lastPosition",0,"1i"),t.setUniformForProgram("centerTexture","u_textureDim",[Q,Q],"2f"),t.createProgram("copyTexture","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform sampler2D u_orig;\nuniform vec2 u_textureDim;\nvoid main(){\n  gl_FragColor = texture2D(u_orig, gl_FragCoord.xy/u_textureDim);\n}\n"),t.setUniformForProgram("copyTexture","u_orig",0,"1i"),t.setUniformForProgram("copyTexture","u_textureDim",[Q,Q],"2f"),t.createProgram("updateCreaseGeo","attribute vec2 a_position;\nvoid main() {\n   gl_Position = vec4(a_position, 0, 1);\n}\n","precision mediump float;\nuniform vec2 u_textureDim;\nuniform vec2 u_textureDimCreases;\nuniform sampler2D u_lastPosition;\nuniform sampler2D u_originalPosition;\nuniform sampler2D u_creaseMeta2;\n\nvec3 getPosition(float index1D){\n  vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);\n  vec2 scaledIndex = index/u_textureDim;\n  return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;\n}\n\nvoid main(){\n  vec2 fragCoord = gl_FragCoord.xy;\n  vec2 scaledFragCoord = fragCoord/u_textureDimCreases;\n\n  vec4 creaseMeta = texture2D(u_creaseMeta2, scaledFragCoord);\n\n  vec3 node1 = getPosition(creaseMeta[0]);\n  vec3 node2 = getPosition(creaseMeta[1]);\n  vec3 node3 = getPosition(creaseMeta[2]);\n  vec3 node4 = getPosition(creaseMeta[3]);\n\n  float tol = 0.000001;\n\n  vec3 creaseVector = node4-node3;\n  float creaseLength = length(creaseVector);\n\n  if (abs(creaseLength)<tol) {\n    gl_FragColor = vec4(-1);//disable crease\n    return;\n  }\n  creaseVector /= creaseLength;\n\n  vec3 vector1 = node1-node3;\n  vec3 vector2 = node2-node3;\n\n  float proj1Length = dot(creaseVector, vector1);\n  float proj2Length = dot(creaseVector, vector2);\n\n  float dist1 = sqrt(abs(vector1.x*vector1.x+vector1.y*vector1.y+vector1.z*vector1.z-proj1Length*proj1Length));\n  float dist2 = sqrt(abs(vector2.x*vector2.x+vector2.y*vector2.y+vector2.z*vector2.z-proj2Length*proj2Length));\n\n  if (dist1<tol || dist2<tol){\n    gl_FragColor = vec4(-1);//disable crease\n    return;\n  }\n\n  gl_FragColor = vec4(dist1, dist2, proj1Length/creaseLength, proj2Length/creaseLength);\n}"),t.setUniformForProgram("updateCreaseGeo","u_lastPosition",0,"1i"),t.setUniformForProgram("updateCreaseGeo","u_originalPosition",1,"1i"),t.setUniformForProgram("updateCreaseGeo","u_creaseMeta2",2,"1i"),t.setUniformForProgram("updateCreaseGeo","u_textureDim",[Q,Q],"2f"),t.setUniformForProgram("updateCreaseGeo","u_textureDimCreases",[oe,oe],"2f"),t.setSize(Q,Q),Z=!0}function n(e){var t=Math.pow;if(1===e)return 2;for(var o=0;o<e;o+=1)if(t(2,2*o)>=e)return t(2,o);return console.warn("no texture size found for "+e+" items"),2}function l(t){for(var o=0,r=0;r<y.length;r+=1){t&&(N[4*r]=o,N[4*r+1]=y[r].numBeams());for(var s,n=0;n<y[r].beams.length;n+=1)s=y[r].beams[n],z[4*o]=s.getK(),z[4*o+1]=s.getD(),t&&(z[4*o+2]=s.getLength(),z[4*o+3]=s.getOtherNode(y[r]).getIndex()),o+=1}e.gpuMath.initTextureFromData("u_beamMeta",ee,ee,"FLOAT",z,!0),Z&&(e.gpuMath.setProgram("velocityCalc"),e.gpuMath.setUniformForProgram("velocityCalc","u_axialStiffness",e.axialStiffness,"1f"),e.gpuMath.setUniformForProgram("velocityCalc","u_faceStiffness",e.faceStiffness,"1f"),e.gpuMath.setProgram("positionCalcVerlet"),e.gpuMath.setUniformForProgram("positionCalcVerlet","u_axialStiffness",e.axialStiffness,"1f"),e.gpuMath.setUniformForProgram("positionCalcVerlet","u_faceStiffness",e.faceStiffness,"1f"),a())}function u(){for(var t,o=0;o<y.length;o+=1)t=y[o].getExternalForce(),B[4*o]=t.x,B[4*o+1]=t.y,B[4*o+2]=t.z;e.gpuMath.initTextureFromData("u_externalForces",Q,Q,"FLOAT",B,!0)}function d(){for(var t=0;t<y.length;t+=1)U[4*t+1]=y[t].isFixed()?1:0;e.gpuMath.initTextureFromData("u_mass",Q,Q,"FLOAT",U,!0)}function g(){for(var t,o=0;o<y.length;o+=1)t=y[o].getOriginalPosition(),M[4*o]=t.x,M[4*o+1]=t.y,M[4*o+2]=t.z;e.gpuMath.initTextureFromData("u_originalPosition",Q,Q,"FLOAT",M,!0)}function m(){for(var t=0;t<P.length;t+=1){var o=4*t,r=P[t].edge.nodes;Y[o]=r[0].getIndex(),Y[o+1]=r[1].getIndex()}e.gpuMath.initTextureFromData("u_creaseVectors",oe,oe,"FLOAT",Y,!0)}function f(t){for(var o,r=0;r<P.length;r+=1)o=P[r],H[4*r]=o.getK(),t&&(H[4*r+2]=o.getTargetTheta());e.gpuMath.initTextureFromData("u_creaseMeta",oe,oe,"FLOAT",H,!0)}function h(){for(var t,o=0;o<y.length;o+=1)t=y[o].getRelativePosition(),V[4*o]=t.x,V[4*o+1]=t.y,V[4*o+2]=t.z;e.gpuMath.initTextureFromData("u_lastPosition",Q,Q,"FLOAT",V,!0),e.gpuMath.initFrameBufferForTexture("u_lastPosition",!0)}function p(t){Z&&(e.gpuMath.setProgram("velocityCalc"),e.gpuMath.setUniformForProgram("velocityCalc","u_creasePercent",t,"1f"),e.gpuMath.setProgram("positionCalcVerlet"),e.gpuMath.setUniformForProgram("positionCalcVerlet","u_creasePercent",t,"1f"))}function _(){var t=Math.acos;Q=n(y.length);for(var o=0,r=[],s=0;s<y.length;s+=1){r.push([]);for(var h=0;h<F.length;h+=1)0<=F[h].indexOf(s)&&(r[s].push(h),o+=1)}ae=n(o);for(var _=0,C=0;C<y.length;C+=1)_+=y[C].numBeams();ee=n(_);var D=P.length;oe=n(D);for(var T=0,L=0;L<y.length;L+=1)T+=y[L].numCreases();T+=2*D,re=n(T);var Z=F.length;te=n(Z),M=new Float32Array(4*(Q*Q)),A=new Float32Array(4*(Q*Q)),V=new Float32Array(4*(Q*Q)),I=new Float32Array(4*(Q*Q)),S=new Float32Array(4*(Q*Q)),E=new Float32Array(4*(Q*Q)),B=new Float32Array(4*(Q*Q)),U=new Float32Array(4*(Q*Q)),N=new Float32Array(4*(Q*Q)),w=new Float32Array(4*(Q*Q)),z=new Float32Array(4*(ee*ee)),O=new Float32Array(4*(te*te)),R=new Float32Array(4*(te*te)),H=new Float32Array(4*(oe*oe)),G=new Float32Array(4*(ae*ae)),k=new Float32Array(4*(te*te)),q=new Float32Array(4*(re*re)),X=new Float32Array(4*(oe*oe)),W=new Float32Array(4*(oe*oe)),Y=new Float32Array(4*(oe*oe)),K=new Float32Array(4*(oe*oe)),J=new Float32Array(4*(oe*oe));for(var ie,se=0;se<F.length;se+=1){ie=F[se],R[4*se]=ie[0],R[4*se+1]=ie[1],R[4*se+2]=ie[2];var ne=y[ie[0]].getOriginalPosition(),a=y[ie[1]].getOriginalPosition(),b=y[ie[2]].getOriginalPosition(),c=a.clone().sub(ne).normalize(),le=b.clone().sub(ne).normalize(),ce=b.clone().sub(a).normalize();k[4*se]=t(c.dot(le)),k[4*se+1]=t(-1*c.dot(ce)),k[4*se+2]=t(le.dot(ce)),.1<x(k[4*se]+k[4*se+1]+k[4*se+2]-v)&&console.warn("bad angles")}for(var ue=0;ue<Q*Q;ue+=1)U[4*ue+1]=1;for(var de=0;de<oe*oe;de+=1){if(de>=D){J[4*de+2]=-1,J[4*de+3]=-1;continue}J[4*de+2]=P[de].getNormal1Index(),J[4*de+3]=P[de].getNormal2Index()}for(var ge=0,me=0;me<y.length;me+=1){w[4*me]=ge;var fe=r[me].length;w[4*me+1]=fe;for(var he=0;he<fe;he+=1){var pe=4*(ge+he),_e=F[r[me][he]];G[pe]=r[me][he],G[pe+1]=_e[0]==me?-1:_e[0],G[pe+2]=_e[1]==me?-1:_e[1],G[pe+3]=_e[2]==me?-1:_e[2]}ge+=fe}ge=0;for(var xe=0;xe<y.length;xe+=1){U[4*xe]=y[xe].getSimMass(),N[4*xe+2]=ge;var ve=y[xe].creases,ye=y[xe].invCreases;N[4*xe+3]=ve.length+ye.length;for(var Ce=0;Ce<ve.length;Ce+=1)q[4*ge]=ve[Ce].getIndex(),q[4*ge+1]=ve[Ce].getNodeIndex(y[xe]),ge+=1;for(var be=0;be<ye.length;be+=1)q[4*ge]=ye[be].getIndex(),q[4*ge+1]=ye[be].getNodeIndex(y[xe]),ge+=1}for(var Fe,Pe=0;Pe<P.length;Pe+=1)Fe=P[Pe],X[4*Pe]=Fe.node1.getIndex(),X[4*Pe+1]=Fe.node2.getIndex(),X[4*Pe+2]=Fe.edge.nodes[0].getIndex(),X[4*Pe+3]=Fe.edge.nodes[1].getIndex(),ge+=1;g(),l(!0),d(),u(),f(!0),m(),p(e.creasePercent)}var y,C,F,P,D,T,M,A,V,I,S,E,B,U,N,w,z,O,R,k,G,H,X,q,W,Y,K,J,Z=!1,Q=0,ee=0,te=0,oe=0,re=0,ae=0;return{syncNodesAndEdges:function(){y=e.model.getNodes(),C=e.model.getEdges(),F=e.model.getFaces(),P=e.model.getCreases(),D=e.model.getPositionsArray(),T=e.model.getColorsArray(),_(),s(e.gpuMath),a()},updateFixed:d,solve:function(a){if(e.shouldAnimateFoldPercent&&(e.creasePercent=e.videoAnimator.nextFoldAngle(0),e.controls.updateCreasePercent(),p(e.creasePercent),e.shouldChangeCreasePercent=!0),e.forceHasChanged&&(u(),e.forceHasChanged=!1),e.fixedHasChanged&&(d(),e.fixedHasChanged=!1),e.nodePositionHasChanged&&(h(),e.nodePositionHasChanged=!1),e.creaseMaterialHasChanged&&(f(),e.creaseMaterialHasChanged=!1),e.materialHasChanged&&(l(),e.materialHasChanged=!1),e.shouldChangeCreasePercent&&(p(e.creasePercent),e.shouldChangeCreasePercent=!1),e.shouldCenterGeo){var i=o();e.gpuMath.setProgram("centerTexture"),e.gpuMath.setUniformForProgram("centerTexture","u_center",[i.x,i.y,i.z],"3f"),e.gpuMath.step("centerTexture",["u_lastPosition"],"u_position"),"verlet"===e.integrationType&&e.gpuMath.step("copyTexture",["u_position"],"u_lastLastPosition"),e.gpuMath.swapTextures("u_position","u_lastPosition"),e.gpuMath.step("zeroTexture",[],"u_lastVelocity"),e.gpuMath.step("zeroTexture",[],"u_velocity"),e.shouldCenterGeo=!1}void 0===a&&(a=e.numSteps);for(var s=0;s<a;s+=1)t();r()},render:r,reset:function(){e.gpuMath.step("zeroTexture",[],"u_position"),e.gpuMath.step("zeroTexture",[],"u_lastPosition"),e.gpuMath.step("zeroTexture",[],"u_lastLastPosition"),e.gpuMath.step("zeroTexture",[],"u_velocity"),e.gpuMath.step("zeroTexture",[],"u_lastVelocity"),e.gpuMath.step("zeroThetaTexture",["u_lastTheta"],"u_theta"),e.gpuMath.step("zeroThetaTexture",["u_theta"],"u_lastTheta"),r()}}}function m(e,t){this.type="beam",this.globals=e,t[0].addBeam(this),t[1].addBeam(this),this.vertices=[t[0]._originalPosition,t[1]._originalPosition],this.nodes=t,this.originalLength=this.getLength()}function f(e,t,o,r,a,s,n,l,c){this.globals=e,this.edge=t;for(var u=0;u<t.nodes.length;u+=1)t.nodes[u].addInvCrease(this);this.face1Index=o,this.face2Index=r,this.targetTheta=a,this.type=s,this.node1=n,this.node2=l,this.index=c,n.addCrease(this),l.addCrease(this)}function h(e){function t(){T&&(M.geometry=null,A.geometry=null,T.dispose()),T=new w.BufferGeometry,M.geometry=T,A.geometry=T,T.dynamic=!0,Object.values(L).forEach(function(e){var t=e.geometry;t&&(e.geometry=null,t.dispose()),t=new w.BufferGeometry,e.geometry=t,t.dynamic=!0})}function o(){var t=.5;"axialStrain"===e.colorMode?(P=new w.MeshBasicMaterial({vertexColors:w.VertexColors,side:w.DoubleSide,polygonOffset:!0,polygonOffsetFactor:t,polygonOffsetUnits:1}),A.visible=!1,!e.threeView.simulationRunning&&(g().render(),u())):(P=new w.MeshPhongMaterial({flatShading:!0,side:w.FrontSide,polygonOffset:!0,polygonOffsetFactor:t,polygonOffsetUnits:1,shininess:1,specular:16777215,reflectivity:0}),D=new w.MeshPhongMaterial({flatShading:!0,side:w.BackSide,polygonOffset:!0,polygonOffsetFactor:t,polygonOffsetUnits:1,shininess:1,specular:16777215,reflectivity:0}),P.color.setStyle("#".concat(e.color1)),D.color.setStyle("#".concat(e.color2)),A.visible=!0),M.material=P,A.material=D,M.material.needsUpdate=!0,A.material.needsUpdate=!0,M.castShadow=!0,M.receiveShadow=!0}function r(){S.visible=e.edgesVisible&&e.mtnsVisible,E.visible=e.edgesVisible&&e.valleysVisible,U.visible=e.edgesVisible&&e.panelsVisible,I.visible=e.edgesVisible&&e.passiveEdgesVisible,N.visible=e.edgesVisible&&e.boundaryEdgesVisible,B.visible=!1}function a(){M.visible=e.meshVisible,A.visible="color"===e.colorMode&&e.meshVisible}function i(){return T}function s(){return z}function n(){return O}function c(){g().reset(),u()}function u(){T.attributes.position.needsUpdate=!0,"axialStrain"===e.colorMode&&(T.attributes.color.needsUpdate=!0),(e.userInteractionEnabled||e.vrEnabled)&&T.computeBoundingBox()}function d(){e.threeView.startAnimation()}function g(){return"dynamic"===e.simType?e.dynamicSolver:"static"===e.simType?e.staticSolver:e.rigidSolver}function h(t,o){return 0===t.vertices_coords.length?void e.warn("No geometry found."):0===t.faces_vertices.length?void e.warn("No faces found, try adjusting import vertex merge tolerance."):0===t.edges_vertices.length?void e.warn("No edges found."):void(H=t,G=o,e.needsSync=!0,e.simNeedsSync=!0,!J&&(d(),J=!0))}function p(){for(var o=0;o<X.length;o+=1)X[o].destroy();for(var s=0;s<W.length;s+=1)W[s].destroy();for(var n=0;n<Y.length;n+=1)Y[n].destroy();R=H,X=[],W=[],q=R.faces_vertices,Y=[],k=G;for(var u,d=R.edges_vertices,g=[],h=0;h<R.vertices_coords.length;h+=1)u=R.vertices_coords[h],g.push(new w.Vector3(u[0],u[1],u[2]));for(var p=0;p<g.length;p+=1)X.push(new l(e,g[p].clone(),X.length));for(var x=0;x<d.length;x+=1)W.push(new m(e,[X[d[x][0]],X[d[x][1]]]));for(var y=0;y<k.length;y+=1){var C=k[y],b=0===C[5]?0:1;Y.push(new f(e,W[C[4]],C[0],C[2],C[5]*v/180,b,X[C[1]],X[C[3]],Y.length))}K=[];for(var F=0;F<X.length;F+=1)K.push(X[F].getOriginalPosition());e.noCreasePatternAvailable()&&"pattern"===e.navMode&&(e.navMode="simulation"),z=new Float32Array(3*K.length),O=new Float32Array(3*K.length),j=new Uint16Array(3*q.length);for(var P=0;P<K.length;P+=1)z[3*P]=K[P].x,z[3*P+1]=K[P].y,z[3*P+2]=K[P].z;for(var D,M=0;M<q.length;M+=1)D=q[M],j[3*M]=D[0],j[3*M+1]=D[1],j[3*M+2]=D[2];t();for(var A=new w.BufferAttribute(z,3),V={U:[],V:[],M:[],B:[],F:[],C:[]},I=0;I<R.edges_assignment.length;I+=1){var S=R.edges_vertices[I],E=R.edges_assignment[I];V[E].push(S[0]),V[E].push(S[1])}Object.keys(L).forEach(function(e){for(var t=V[e],o=new Uint16Array(t.length),r=0;r<t.length;r+=1)o[r]=t[r];L[e].geometry.addAttribute("position",A),L[e].geometry.setIndex(new w.BufferAttribute(o,1)),L[e].geometry.computeBoundingBox(),L[e].geometry.computeBoundingSphere(),L[e].geometry.center()}),T.addAttribute("position",A),T.addAttribute("color",new w.BufferAttribute(O,3)),T.setIndex(new w.BufferAttribute(j,1)),T.computeVertexNormals(),T.computeBoundingBox(),T.computeBoundingSphere(),T.center();var B=1/T.boundingSphere.radius;e.scale=B;for(var U=0;U<z.length;U+=1)z[U]*=B;for(var N=0;N<K.length;N+=1)K[N].multiplyScalar(B);for(var J=0;J<K.length;J+=1)X[J].setOriginalPosition(z[3*J],z[3*J+1],z[3*J+2]);for(var Z=0;Z<W.length;Z+=1)W[Z].recalcOriginalLength();r(),a(),_(),e.needsSync=!1,e.simulationRunning||c()}function _(){g().syncNodesAndEdges(),e.simNeedsSync=!1}function x(){return X}function y(){return W}function C(){return q}function b(){return Y}function F(){return T.computeBoundingBox(),T.boundingBox.max.clone().sub(T.boundingBox.min)}var P,D,T,M=new w.Mesh,A=new w.Mesh;A.visible=!1;var V=new w.LineBasicMaterial({color:0,linewidth:1,transparent:!0,opacity:.3}),I=new w.LineSegments(null,V),S=new w.LineSegments(null,V),E=new w.LineSegments(null,V),B=new w.LineSegments(null,V),U=new w.LineSegments(null,V),N=new w.LineSegments(null,V),L={U:I,M:S,V:E,C:B,F:U,B:N};t(),o(),e.threeView.sceneAddModel(M),e.threeView.sceneAddModel(A),Object.values(L).forEach(function(t){e.threeView.sceneAddModel(t)});var z,O,j,R,k,G,H,X=[],q=[],W=[],Y=[],K=[],J=!1;return{pause:function(){e.threeView.pauseSimulation()},resume:function(){e.threeView.startSimulation()},reset:c,step:function(e){g().solve(e),u()},getNodes:x,getEdges:y,getFaces:C,getCreases:b,getGeometry:i,getPositionsArray:s,getColorsArray:n,getMesh:function(){return[M,A]},buildModel:h,sync:p,syncSolver:_,setMeshMaterial:o,updateEdgeVisibility:r,updateMeshVisibility:a,getDimensions:F}}function p(e){function t(){Z.vertices_coords=[],Z.edges_vertices=[],Z.edges_assignment=[],Z.edges_foldAngle=[],delete Z.vertices_vertices,delete Z.faces_vertices,delete Z.vertices_edges,Q={}}function r(){t(),ee=[],te=[],oe=[],re=[],ae=[],ie=[],se=[],le=[],ce=[],ue=[],de=[],ge=[],ne=[]}function a(e){var t=e.getAttribute("opacity");return void 0===t&&(e.style&&e.style.opacity&&(t=e.style.opacity),void 0===t&&(t=e.getAttribute("stroke-opacity"),void 0===t&&e.style&&e.style["stroke-opacity"]&&(t=e.style["stroke-opacity"]))),t=parseFloat(t),isNaN(t)?1:t}function i(e){var t=e.getAttribute("stroke");return void 0===t?e.style&&e.style.stroke?(t=e.style.stroke.toLowerCase(),t=t.replace(/\s/g,""),t):null:(t=t.replace(/\s/g,""),t.toLowerCase())}function s(e){return"#000000"===e||"#000"===e||"black"===e||"rgb(0,0,0)"===e?"border":"#ff0000"===e||"#f00"===e||"red"===e||"rgb(255,0,0)"===e?"mountain":"#0000ff"===e||"#00f"===e||"blue"===e||"rgb(0,0,255)"===e?"valley":"#00ff00"===e||"#0f0"===e||"green"===e||"rgb(0,255,0)"===e?"cut":"#ffff00"===e||"#ff0"===e||"yellow"===e||"rgb(255,255,0)"===e?"triangulation":"#ff00ff"===e||"#f0f"===e||"magenta"===e||"rgb(255,0,255)"===e?"hinge":(ne.push(e),null)}function n(e){return"B"===e?"#000":"M"===e?"#f00":"V"===e?"#00f":"C"===e?"#0f0":"F"===e?"#ff0":"U"===e?"#f0f":"#0ff"}function l(e,t){return null===e||"F"===t?1:x(e)/180}function c(e,r){if(void 0!==r){r=r.baseVal;for(var a=0;a<r.length;a+=1){var s=r[a],t=s.matrix,n=fe([e.x,e.z],[t.a,t.b,t.c,t.d,t.e,t.f]),l=o(n,2);e.x=l[0],e.z=l[1]}}}function u(e){var t=i(e);return"border"===s(t)}function d(e){var t=i(e);if("mountain"===s(t)){var o=a(e);return e.targetAngle=180*-o,!0}return!1}function g(e){var t=i(e);if("valley"===s(t)){var o=a(e);return e.targetAngle=180*o,!0}return!1}function m(e){var t=i(e);return"cut"===s(t)}function f(e){var t=i(e);return"triangulation"===s(t)}function h(e){var t=i(e);return"hinge"===s(t)}function p(e,t,o,r,a,i,s,n){v(e,t,r.filter(o)),y(e,t,a.filter(o)),C(e,t,i.filter(o)),b(e,t,s.filter(o)),F(e,t,n.filter(o))}function c(e,o){if(null!=o){o=o.baseVal;for(var r=0;r<o.length;r+=1){var a=o[r],t=[[a.matrix.a,a.matrix.c,a.matrix.e],[a.matrix.b,a.matrix.d,a.matrix.f],[0,0,1]],s=numeric.dot(t,[e.x,e.z,1]);e.x=s[0],e.z=s[1]}}}function v(e,t,o){for(var r=0;r<o.length;r+=1){var a=o[r],s=[];if(void 0===a||void 0===a.getPathData){return $("<div id=\"coverImg\" style=\"background: url(assets/doc/crane.gif) no-repeat center center fixed;-webkit-background-size: cover;-moz-background-size: cover;-o-background-size: cover;background-size: cover;\"></div>").appendTo($("body")),$("#noSupportModal").modal("show"),void console.warn("path parser not supported")}for(var n=a.getPathData(),l=0;l<n.length;l+=1){var u=n[l],d=u.type,g=void 0;"m"===d?(0===l?g=new z.Vector3(u.values[0],0,u.values[1]):(g=e[e.length-1].clone(),g.x+=u.values[0],g.z+=u.values[1]),e.push(g),s.push(g)):"l"===d?(t.push([e.length-1,e.length]),a.targetAngle&&0<t.length&&t[t.length-1].push(a.targetAngle),g=e[e.length-1].clone(),g.x+=u.values[0],g.z+=u.values[1],e.push(g),s.push(g)):"v"===d?(t.push([e.length-1,e.length]),a.targetAngle&&0<t.length&&t[t.length-1].push(a.targetAngle),g=e[e.length-1].clone(),g.z+=u.values[0],e.push(g),s.push(g)):"h"===d?(t.push([e.length-1,e.length]),a.targetAngle&&0<t.length&&t[t.length-1].push(a.targetAngle),g=e[e.length-1].clone(),g.x+=u.values[0],e.push(g),s.push(g)):"M"===d?(g=new z.Vector3(u.values[0],0,u.values[1]),e.push(g),s.push(g)):"L"===d?(t.push([e.length-1,e.length]),a.targetAngle&&0<t.length&&t[t.length-1].push(a.targetAngle),e.push(new z.Vector3(u.values[0],0,u.values[1])),s.push(g)):"V"===d?(t.push([e.length-1,e.length]),a.targetAngle&&0<t.length&&t[t.length-1].push(a.targetAngle),g=e[e.length-1].clone(),g.z=u.values[0],e.push(g),s.push(g)):"H"===d?(t.push([e.length-1,e.length]),a.targetAngle&&0<t.length&&t[t.length-1].push(a.targetAngle),g=e[e.length-1].clone(),g.x=u.values[0],e.push(g),s.push(g)):void 0}for(var m=0;m<s.length;m++)c(s[m],a.transform)}}function y(e,t,o){for(var r,a=0;a<o.length;a++)r=o[a],e.push(new z.Vector3(r.x1.baseVal.value,0,r.y1.baseVal.value)),e.push(new z.Vector3(r.x2.baseVal.value,0,r.y2.baseVal.value)),t.push([e.length-2,e.length-1]),r.targetAngle&&t[t.length-1].push(r.targetAngle),c(e[e.length-2],r.transform),c(e[e.length-1],r.transform)}function C(e,t,o){for(var r=0;r<o.length;r++){var a=o[r],s=a.x.baseVal.value,n=a.y.baseVal.value,l=a.width.baseVal.value,u=a.height.baseVal.value;e.push(new z.Vector3(s,0,n)),e.push(new z.Vector3(s+l,0,n)),e.push(new z.Vector3(s+l,0,n+u)),e.push(new z.Vector3(s,0,n+u)),t.push([e.length-4,e.length-3]),t.push([e.length-3,e.length-2]),t.push([e.length-2,e.length-1]),t.push([e.length-1,e.length-4]);for(var d=1;4>=d;d++)a.targetAngle&&t[t.length-d].push(a.targetAngle),c(e[e.length-d],a.transform)}}function b(e,t,o){for(var r,a=0;a<o.length;a++){r=o[a];for(var s=0;s<r.points.length;s++)e.push(new z.Vector3(r.points[s].x,0,r.points[s].y)),c(e[e.length-1],r.transform),s<r.points.length-1?t.push([e.length-1,e.length]):t.push([e.length-1,e.length-r.points.length]),r.targetAngle&&t[t.length-1].push(r.targetAngle)}}function F(e,t,o){for(var r,a=0;a<o.length;a++){r=o[a];for(var s=0;s<r.points.length;s++)e.push(new z.Vector3(r.points[s].x,0,r.points[s].y)),c(e[e.length-1],r.transform),0<s&&t.push([e.length-1,e.length-2]),r.targetAngle&&t[t.length-1].push(r.targetAngle)}}function D(t,o){Q=JSON.parse(JSON.stringify(t));for(var r,a=0;a<Q.vertices_coords.length;a+=1)r=Q.vertices_coords[a],2===r.length&&(Q.vertices_coords[a]=[r[0],0,r[1]]);0<[].length&&(t=j(t),t=R.convert.edges_vertices_to_vertices_vertices_unsorted(t),t=q(t,.01)),delete t.vertices_vertices,delete t.vertices_edges,Z=K(t,!0);for(var s,n=0;n<Z.vertices_coords.length;n+=1)s=Z.vertices_coords[n],2===s.length&&(Z.vertices_coords[n]=[s[0],0,s[1]]);le=R.filter.mountainEdges(Z),ce=R.filter.valleyEdges(Z),ue=R.filter.boundaryEdges(Z),de=R.filter.unassignedEdges(Z),ge=R.filter.flatEdges(Z);var l=X(Z);return o?l:(e.model.buildModel(Z,l),Z)}function T(t,o,r,a,i,s,n){return(t.forEach(function(e){Z.vertices_coords.push([e.x,e.z])}),o.forEach(function(e){Z.edges_vertices.push([e[0],e[1]]),Z.edges_assignment.push("B"),Z.edges_foldAngle.push(null)}),r.forEach(function(e){Z.edges_vertices.push([e[0],e[1]]),Z.edges_assignment.push("M"),Z.edges_foldAngle.push(e[2])}),a.forEach(function(e){Z.edges_vertices.push([e[0],e[1]]),Z.edges_assignment.push("V"),Z.edges_foldAngle.push(e[2])}),s.forEach(function(e){Z.edges_vertices.push([e[0],e[1]]),Z.edges_assignment.push("F"),Z.edges_foldAngle.push(0)}),n.forEach(function(e){Z.edges_vertices.push([e[0],e[1]]),Z.edges_assignment.push("U"),Z.edges_foldAngle.push(null)}),i.forEach(function(e){Z.edges_vertices.push([e[0],e[1]]),Z.edges_assignment.push("C"),Z.edges_foldAngle.push(null)}),0===Z.vertices_coords.length||0===Z.edges_vertices.length)?(e.warn("No valid geometry found in SVG, be sure to ungroup all and remove all clipping masks."),!1):(Z=R.filter.collapseNearbyVertices(Z,e.vertTol),R.filter.removeLoopEdges(Z),R.filter.subdivideCrossingEdges_vertices(Z,e.vertTol),Z=J(Z,e.vertTol),Z=R.filter.collapseNearbyVertices(Z,e.vertTol),R.filter.removeLoopEdges(Z),R.filter.removeDuplicateEdges_vertices(Z),Z=R.convert.edges_vertices_to_vertices_vertices_unsorted(Z),Z=Y(Z),Z=q(Z,.01),R.convert.sort_vertices_vertices(Z),Z=R.convert.vertices_vertices_to_faces_vertices(Z),Z=N(Z),Z=H(Z),Z=U(Z),D(Z))}function M(e){return 2===e.length?A(e):V(e)}function A(e){return new z.Vector2(e[0],e[1])}function V(e){return new z.Vector3(e[0],e[1],e[2])}function I(e,t,o){var r=e*t;return r<-o?null:r>t+o?null:r}function S(e,t,o,r){var a=e.x,i=e.y,s=t.x,n=t.y,l=o.x,c=o.y,u=r.x,d=r.y,g=(d-c)*(s-a)-(u-l)*(n-i);if(0===g)return null;var m=((u-l)*(i-c)-(d-c)*(a-l))/g;return{intersection:new z.Vector2(a+m*(s-a),i+m*(n-i)),t1:m,t2:((s-a)*(i-c)-(n-i)*(a-l))/g}}function E(e){return e?Q:Z}function B(){return Z.faces_vertices}function U(e){for(var t=0;t<e.faces_vertices.length;t+=1)e.faces_vertices[t].reverse();return e}function N(e){for(var t=[],o=0;o<e.vertices_coords.length;o+=1)t.push([]);for(var r,a=0;a<e.edges_vertices.length;a+=1)r=e.edges_vertices[a],t[r[0]].push(a),t[r[1]].push(a);return e.vertices_edges=t,e}function L(e){for(var t=[],o=0;o<e.vertices_coords.length;o+=1)t.push([]);for(var r,a=0;a<e.faces_vertices.length;a+=1){r=e.faces_vertices[a];for(var s=0;s<r.length;s+=1)t[r[s]].push(a)}return e.vertices_faces=t,e}function w(e){for(var t=0;t<e.vertices_vertices.length;t+=1){for(var o,r=e.vertices_vertices[t],a=e.vertices_edges[t],s=[],n=0;n<r.length;n+=1){o=-1;for(var l=0;l<a.length;l+=1){var c=a[l],u=e.edges_vertices[c];if(0<=u.indexOf(r[n])){o=c;break}}0>o&&console.warn("no matching edge found, fix this"),s.push(o)}e.vertices_edges[t]=s}return e}function j(e){e=w(e),e=L(e);for(var t=0;t<e.vertices_edges.length;t+=1){for(var o=[[]],r=0,s=e.vertices_edges[t],n=e.vertices_faces[t],l=0;l<s.length;l+=1){var c=s[l],u=e.edges_assignment[c];if(o[r].push(c),"C"===u){o.push([e.edges_vertices.length]),r+=1;var d=e.edges_vertices.length,g=e.edges_vertices[c];e.edges_vertices.push([g[0],g[1]]),e.edges_assignment[c]="B",e.edges_foldAngle.push(null),e.edges_assignment.push("B");var m=g[0];m===t&&(m=g[1]);var f=e.vertices_edges[m],h=f.indexOf(c);f.splice(h,0,d)}else if("B"===u)if(0===l&&1<s.length){var p=s[1];if("B"===e.edges_assignment[p]){var _=e.edges_vertices[c],v=_[0];v===t&&(v=_[1]);var y=e.edges_vertices[p],C=y[0];if(C===t&&(C=y[1]),G(e,e.vertices_faces[t],v,C));else o.push([]),r+=1}}else 1<o[r].length&&(o.push([]),r+=1)}if(!(1>=o.length)){for(var b=o[r].length-1;0<=b;b-=1)o[0].unshift(o[r][b]);o.pop();for(var F=1;F<o.length;F+=1){var P=e.vertices_coords[t],D=e.vertices_coords.length;e.vertices_coords.push(P.slice());for(var T=[],M=0;M<o[F].length;M+=1){var A=o[F][M],V=e.edges_vertices[A],I=V[0];V[0]===t?(V[0]=D,I=V[1]):V[1]=D,T.push(I)}if(2>T.length)console.warn("problem here");else for(var S=1;S<T.length;S+=1){for(var E=T[S],B=T[S-1],U=!1,N=0;N<n.length;N+=1){var z=e.faces_vertices[n[N]],O=z.indexOf(E),R=z.indexOf(B),H=z.indexOf(t);if(0<=O&&0<=R&&0<=H&&(1===x(O-H)||x(O-H)===z.length-1)&&(1===x(R-H)||x(R-H)===z.length-1)){U=!0,z[H]=D;break}}U||console.warn("problem here")}}}}return delete e.vertices_faces,delete e.vertices_edges,delete e.vertices_vertices,e}function G(e,t,o,r){if(o===r)return!1;for(var i,s=0;s<t.length;s+=1)if(i=e.faces_vertices[t[s]],0<=i.indexOf(o)&&0<=i.indexOf(r))return!0;return!1}function H(e){for(var t=e.faces_vertices.length-1;0<=t;t-=1){for(var o=e.faces_vertices[t],r=!0,a=0;a<o.length;a+=1){var s=o[a],n=a+1;n>=o.length&&(n=0);for(var l=o[n],c=!1,u=0;u<e.vertices_edges[s].length;u+=1){var d=e.vertices_edges[s][u],g=e.edges_vertices[d];if(g[0]===s&&g[1]===l||g[1]===s&&g[0]===l){c=!0;var m=e.edges_assignment[d];if("B"!==m){r=!1;break}}}if(c||console.warn("no connecting edge found on face"),!r)break}r&&e.faces_vertices.splice(t,1)}return e}function X(e){for(var t,o=[],r=e.faces_vertices,a=0;a<e.edges_vertices.length;a+=1)if(t=e.edges_assignment[a],"M"===t||"V"===t||"F"===t)for(var s=e.edges_vertices[a],n=s[0],l=s[1],c=[],u=0;u<r.length;u+=1){var d=r[u],g=[d[0],d[1],d[2]],m=g.indexOf(n);if(0<=m){var f=g.indexOf(l);if(0<=f&&(c.push(u),f>m?(g.splice(f,1),g.splice(m,1)):(g.splice(m,1),g.splice(f,1)),c.push(g[0]),4===c.length)){(1==f-m||-2==f-m)&&(c=[c[2],c[3],c[0],c[1]]),c.push(a);var h=e.edges_foldAngle[a];c.push(h),o.push(c);break}}}return o}function q(e,t){for(var o,r=[],a=0,s=0,n=0;n<e.vertices_vertices.length;n+=1){if(o=e.vertices_vertices[n],2!==o.length){r.push(s++);continue}var l=e.vertices_coords[n],c=e.vertices_coords[o[0]],u=e.vertices_coords[o[1]],d=3===l.length,g=[c[0]-l[0],c[1]-l[1]],m=[u[0]-l[0],u[1]-l[1]],f=g[0]*g[0]+g[1]*g[1],h=m[0]*m[0]+m[1]*m[1],p=g[0]*m[0]+g[1]*m[1];if(d&&(g.push(c[2]-l[2]),m.push(u[2]-l[2]),f+=g[2]*g[2],h+=m[2]*m[2],p+=g[2]*m[2]),p/=_(f*h),x(p+1)<t){var v=W(e,o[0],n,o[1]);if(v)a+=1,r.push(null);else{r.push(s++);continue}}else r.push(s++)}if(0===a)return e;if(console.warn("".concat(a," redundant vertices found")),e=R.filter.remapField(e,"vertices",r),e.faces_vertices)for(var y,C=0;C<e.faces_vertices.length;C+=1){y=e.faces_vertices[C];for(var b=y.length-1;0<=b;b-=1)null===y[b]&&y.splice(b,1)}return e}function W(e,t,o,r){for(var a,s=0,n=0,l=[],c=null,u=[],d=e.edges_vertices.length-1;0<=d;d-=1)if(a=e.edges_vertices[d],0<=a.indexOf(o)&&(0<=a.indexOf(t)||0<=a.indexOf(r))){if(null===c)c=e.edges_assignment[d];else if(c!==e.edges_assignment[d])return console.log(c,e.edges_assignment[d]),console.warn("different edge assignments"),!1;var g=e.edges_foldAngle[d];isNaN(g)&&console.log(d),l.push(g),g&&(s+=g,n+=1),u.push(d)}l[0]!==l[1]&&console.warn("incompatible angles: "+JSON.stringify(l));for(var m,f=0;f<u.length;f+=1)m=u[f],e.edges_vertices.splice(m,1),e.edges_assignment.splice(m,1),e.edges_foldAngle.splice(m,1);e.edges_vertices.push([t,r]),e.edges_assignment.push(c),0<n?e.edges_foldAngle.push(s/n):e.edges_foldAngle.push(null);var h=e.vertices_vertices[t].indexOf(o);return e.vertices_vertices[t].splice(h,1),e.vertices_vertices[t].push(r),h=e.vertices_vertices[r].indexOf(o),e.vertices_vertices[r].splice(h,1),e.vertices_vertices[r].push(t),!0}function Y(e){e.vertices_vertices||(console.warn("compute vertices_vertices first"),e=R.convert.edges_vertices_to_vertices_vertices_unsorted(e));for(var t=0,o=[],r=0,a=0;a<e.vertices_vertices.length;a+=1)void 0===e.vertices_vertices[a]||0===e.vertices_vertices[a].length?(t++,o.push(null)):o.push(r++);return 0===t?e:(console.warn("".concat(t," stray vertices found")),R.filter.remapField(e,"vertices",o))}function K(e,t){for(var o,r=e.vertices_coords,a=e.faces_vertices,s=e.edges_vertices,n=e.edges_foldAngle,l=e.edges_assignment,c=[],u=0;u<a.length;u+=1){if(o=a[u],3===o.length){c.push(o);continue}if(4===o.length){var d=M(r[o[0]]),g=M(r[o[1]]),m=M(r[o[2]]),f=M(r[o[3]]),h=d.clone().sub(m).lengthSq(),p=g.clone().sub(f).lengthSq();p<h?(s.push([o[1],o[3]]),n.push(0),l.push("F"),c.push([o[0],o[1],o[3]]),c.push([o[1],o[2],o[3]])):(s.push([o[0],o[2]]),n.push(0),l.push("F"),c.push([o[0],o[1],o[2]]),c.push([o[0],o[2],o[3]]));continue}for(var _,x=[],v=0;v<s.length;v+=1)_=s[v],0<=o.indexOf(_[0])&&0<=o.indexOf(_[1])&&x.push(v);for(var y,C=[],b=0;b<o.length;b+=1)y=r[o[b]],C.push(y[0]),C.push(y[1]),t||C.push(y[2]);for(var F=O(C,null,t?2:3),P=0;P<F.length;P+=3){for(var D=[o[F[P+1]],o[F[P+2]],o[F[P]]],T=[!1,!1,!1],A=0;A<x.length;A+=1){var V=s[x[A]],I=V.indexOf(D[0]),S=V.indexOf(D[1]),E=V.indexOf(D[2]);if(0<=I){if(0<=S){T[0]=!0;continue}if(0<=E){T[2]=!0;continue}}if(0<=S&&0<=E){T[1]=!0;continue}}for(var B=0;3>B;B+=1)T[B]||(0===B?(x.push(s.length),s.push([D[0],D[1]]),n.push(0),l.push("F")):1===B?(x.push(s.length),s.push([D[2],D[1]]),n.push(0),l.push("F")):2==B&&(x.push(s.length),s.push([D[2],D[0]]),n.push(0),l.push("F")));c.push(D)}}return e.faces_vertices=c,e}function J(e,t){for(var o=e.vertices_coords,r=e.edges_vertices,a=e.edges_foldAngle,s=e.edges_assignment,n=r.length-1;0<=n;n-=1)for(var l=n-1;0<=l;l-=1){var c=A(o[r[n][0]]),u=A(o[r[n][1]]),d=A(o[r[l][0]]),g=A(o[r[l][1]]),m=S(c,u,d,g);if(m){var f=u.clone().sub(c).length(),h=g.clone().sub(d).length(),p=I(m.t1,f,t),_=I(m.t2,h,t);if(null===p||null===_)continue;var x=p>t&&p<f-t,v=_>t&&_<h-t;if(!x&&!v)continue;var y=void 0;if(x&&v?(y=o.length,o.push([m.intersection.x,m.intersection.y])):x?_<=t?y=r[l][0]:y=r[l][1]:p<=t?y=r[n][0]:y=r[n][1],x){var C=a[n],b=s[n];r.splice(n,1,[y,r[n][0]],[y,r[n][1]]),a.splice(n,1,C,C),s.splice(n,1,b,b),n+=1}if(v){var F=a[l],P=s[l];r.splice(l,1,[y,r[l][0]],[y,r[l][1]]),a.splice(l,1,F,F),s.splice(l,1,P,P),l+=1,n+=1}}}return e}var Z={},Q={},ee=[],te=[],oe=[],re=[],ae=[],ie=[],se=[],ne=[],le=[],ce=[],ue=[],de=[],ge=[];r();var me=new k,fe=function(e,t){return[e[0]*t[0]+e[1]*t[2]+t[4],e[0]*t[1]+e[1]*t[3]+t[5]]};return{loadSVG:function(t){me.load(t,function(t){var o=t.xml;r();var a=Array.from(o.childNodes).filter(function(e){return"style"===e.tagName});0<a.length&&e.warn("Global styling found on SVG, this is currently ignored by the app.  This may cause some lines to be styled incorrectly and missed during import.  Please find a way to save this file without using global style tags.<br/><br/>Global styling:<br/><br/><b>".concat(a.html(),"</b>"));var s=Array.from(o.getElementsByTagName("path")),c=Array.from(o.getElementsByTagName("line")),_=Array.from(o.getElementsByTagName("rect")),x=Array.from(o.getElementsByTagName("polygon")),v=Array.from(o.getElementsByTagName("polyline")),y=function(e){return e.setAttribute("style","fill: none; stroke-dasharray: none;")};if(s.forEach(function(e){return y(e)}),c.forEach(function(e){return y(e)}),_.forEach(function(e){return y(e)}),x.forEach(function(e){return y(e)}),v.forEach(function(e){return y(e)}),p(ee,re,u,s,c,_,x,v),p(ee,te,d,s,c,_,x,v),p(ee,oe,g,s,c,_,x,v),p(ee,ae,m,s,c,_,x,v),p(ee,ie,f,s,c,_,x,v),p(ee,se,h,s,c,_,x,v),0<ne.length){var C={};ne.forEach(function(e){C[e]=!0}),ne=Object.keys(C);var b="Some objects found with the following stroke colors:<br/><br/>";ne.forEach(function(e){b+="<span style='background:"+e+"' class='colorSwatch'></span>"+e+"<br/>"}),b+="<br/>These objects were ignored.<br/>  Please check that your file is set up correctly, <br/>see <b>File > File Import Tips</b> for more information.",e.warn(b)}var F=T(ee,re,te,oe,ae,ie,se);if(F){for(var D,M=new z.Vector3(-Infinity,-Infinity,-Infinity),A=new z.Vector3(1/0,1/0,1/0),V=0;V<Q.vertices_coords.length;V+=1)D=new z.Vector3(Q.vertices_coords[V][0],Q.vertices_coords[V][1],Q.vertices_coords[V][2]),M.max(D),A.min(D);if(A.x===1/0)return void(0===ne.length&&e.warn("no geometry found in file"));M.sub(A);var I=new z.Vector3(.1,0,.1),S=M.x;if(M.z<S&&(S=M.z),0!==S){var E=S/300;I.multiplyScalar(S),A.sub(I),M.add(I.multiplyScalar(2));var B=[A.x,A.z,M.x,M.z].join(" "),U=P.document.createElementNS("http://www.w3.org/2000/svg","svg");U.setAttribute("viewBox",B);for(var N=0;N<Q.edges_vertices.length;N+=1){var L=P.document.createElementNS("http://www.w3.org/2000/svg","line"),w=Q.edges_vertices[N],O=Q.vertices_coords[w[0]];L.setAttribute("stroke",n(Q.edges_assignment[N])),L.setAttribute("opacity",l(Q.edges_foldAngle[N],Q.edges_assignment[N])),L.setAttribute("x1",O[0]),L.setAttribute("y1",O[2]),O=Q.vertices_coords[w[1]],L.setAttribute("x2",O[0]),L.setAttribute("y2",O[2]),L.setAttribute("stroke-width",E),U.appendChild(L)}}}},function(){},function(o){e.warn("Error loading SVG "+t+" : "+o),console.warn(o)})},saveSVG:function(){if("fold"===e.extension)return void e.warn("No crease pattern available for files imported from FOLD format.");var t=new P.XMLSerializer;console.log("pattern.js saveSVG needs testing, check out these 2 lines");var o=P.document.querySelector("#svgViewer>svg"),r=t.serializeToString(o),a=new Blob([r],{type:"image/svg+xml;charset=utf-8"}),i=URL.createObjectURL(a),s=P.document.createElement("a");s.href=i,s.download="".concat(e.filename,".svg"),P.document.body.appendChild(s),s.click(),P.document.body.removeChild(s)},getFoldData:E,getTriangulatedFaces:B,setFoldData:function(e,t){return r(),D(e,t)}}}var y={parent:null,navMode:"simulation",touchMode:"rotate",backgroundColor:"ffffff",colorMode:"color",calcFaceStrain:!1,color1:"ec008b",color2:"ffffff",edgesVisible:!0,mtnsVisible:!0,valleysVisible:!0,panelsVisible:!1,passiveEdgesVisible:!1,boundaryEdgesVisible:!0,meshVisible:!0,ambientOcclusion:!1,simulationRunning:!0,fixedHasChanged:!1,forceHasChanged:!1,materialHasChanged:!1,creaseMaterialHasChanged:!1,shouldResetDynamicSim:!1,shouldChangeCreasePercent:!1,nodePositionHasChanged:!1,shouldZeroDynamicVelocity:!1,shouldCenterGeo:!1,needsSync:!1,simNeedsSync:!1,menusVisible:!0,pausedForPatternView:!1,userInteractionEnabled:!1,vrEnabled:!1,url:null,numSteps:100,simType:"dynamic",scale:1,creasePercent:.6,axialStiffness:20,creaseStiffness:.7,panelStiffness:.7,faceStiffness:.2,percentDamping:.45,density:1,integrationType:"euler",strainClip:5,vertTol:.001,foldUseAngles:!0,filename:null,extension:null,doublesidedSTL:!1,doublesidedOBJ:!1,exportScale:1,thickenModel:!0,thickenOffset:5,polyFacesOBJ:!0,foldUnits:"unit",triangulateFOLDexport:!1,exportFoldAngle:!0,capturer:null,capturerQuality:63,capturerFPS:60,gifFPS:20,currentFPS:null,capturerScale:1,capturerFrames:0,shouldScaleCanvas:!1,isGif:!1,shouldAnimateFoldPercent:!1},C="undefined"!=typeof window&&"undefined"!=typeof window.document,b="undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node,F="object"===("undefined"==typeof self?"undefined":e(self))&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name,P=!b&&C?window:{};if(b){var D=require("xmldom"),T=D.DOMParser,M=D.XMLSerializer;P.DOMParser=T,P.XMLSerializer=M,P.document=new T().parseFromString("<!DOCTYPE html><title>a</title>","text/html")}var A,V=P.THREE||require("three");A=b&&!C?function(){return{}}:P.TrackballControls||require("three-trackballcontrols");var I=P.THREE||require("three"),S=new I.MeshBasicMaterial({color:0,side:I.DoubleSide}),E=new I.MeshBasicMaterial({color:16777215,opacity:.5,transparent:!0}),B=new I.MeshBasicMaterial({color:16777215,opacity:.8,transparent:!0}),U=new I.SphereGeometry(.02,20);l.prototype.setFixed=function(e){this.fixed=e},l.prototype.isFixed=function(){return this.fixed},l.prototype.addExternalForce=function(){},l.prototype.getExternalForce=function(){return this.externalForce?this.externalForce.getForce():new I.Vector3(0,0,0)},l.prototype.addCrease=function(e){this.creases.push(e)},l.prototype.removeCrease=function(e){if(null!==this.creases){var t=this.creases.indexOf(e);0<=t&&this.creases.splice(t,1)}},l.prototype.addInvCrease=function(e){this.invCreases.push(e)},l.prototype.removeInvCrease=function(e){if(null!==this.invCreases){var t=this.invCreases.indexOf(e);0<=t&&this.invCreases.splice(t,1)}},l.prototype.addBeam=function(e){this.beams.push(e)},l.prototype.removeBeam=function(e){if(null!==this.beams){var t=this.beams.indexOf(e);0<=t&&this.beams.splice(t,1)}},l.prototype.getBeams=function(){return this.beams},l.prototype.numBeams=function(){return this.beams.length},l.prototype.isConnectedTo=function(e){for(var t=0;t<this.beams.length;t+=1)if(this.beams[t].getOtherNode(this)==e)return!0;return!1},l.prototype.numCreases=function(){return this.creases.length},l.prototype.getIndex=function(){return this.index},l.prototype.getObject3D=function(){return this.object3D},l.prototype.setTransparent=function(){this.object3D||(this.object3D=new I.Mesh(U,S),this.object3D.visible=!1),this.object3D.material=E},l.prototype.setTransparentVR=function(){this.object3D||(this.object3D=new I.Mesh(U,S),this.object3D.visible=!1),this.object3D.material=B,this.object3D.scale.set(.4,.4,.4)},l.prototype.getOriginalPosition=function(){return this._originalPosition.clone()},l.prototype.setOriginalPosition=function(e,t,o){this._originalPosition.set(e,t,o)},l.prototype.getPosition=function(){var e=this.globals.model.getPositionsArray(),t=this.getIndex();return new I.Vector3(e[3*t],e[3*t+1],e[3*t+2])},l.prototype.moveManually=function(e){var t=this.globals.model.getPositionsArray(),o=this.getIndex();t[3*o]=e.x,t[3*o+1]=e.y,t[3*o+2]=e.z},l.prototype.getRelativePosition=function(){return this.getPosition().sub(this._originalPosition)},l.prototype.getSimMass=function(){return 1},l.prototype.destroy=function(){this.object3D=null,this.beams=null,this.creases=null,this.invCreases=null,this.externalForce=null};var N=P.THREE||require("three"),L=P.THREE||require("three");m.prototype.getLength=function(){return this.getVector().length()},m.prototype.getOriginalLength=function(){return this.originalLength},m.prototype.recalcOriginalLength=function(){this.originalLength=this.getVector().length()},m.prototype.isFixed=function(){return this.nodes[0].fixed&&this.nodes[1].fixed},m.prototype.getVector=function(e){return e===this.nodes[1]?this.vertices[0].clone().sub(this.vertices[1]):this.vertices[1].clone().sub(this.vertices[0])},m.prototype.getK=function(){return this.globals.axialStiffness/this.getLength()},m.prototype.getD=function(){return 2*this.globals.percentDamping*_(this.getK()*this.getMinMass())},m.prototype.getNaturalFrequency=function(){return _(this.getK()/this.getMinMass())},m.prototype.getMinMass=function(){var e=this.nodes[0].getSimMass();return this.nodes[1].getSimMass()<e&&(e=this.nodes[1].getSimMass()),e},m.prototype.getOtherNode=function(e){return this.nodes[0]===e?this.nodes[1]:this.nodes[0]},m.prototype.destroy=function(){var e=this;this.nodes.forEach(function(t){return t.removeBeam(e)}),this.vertices=null,this.nodes=null},f.prototype.getLength=function(){return this.edge.getLength()},f.prototype.getVector=function(e){return this.edge.getVector(e)},f.prototype.getNormal1Index=function(){return this.face1Index},f.prototype.getNormal2Index=function(){return this.face2Index},f.prototype.getTargetTheta=function(){return this.targetTheta},f.prototype.getK=function(){var e=this.getLength();return 0===this.type?this.globals.panelStiffness*e:this.globals.creaseStiffness*e},f.prototype.getD=function(){return 2*this.globals.percentDamping*_(this.getK())},f.prototype.getIndex=function(){return this.index},f.prototype.getLengthToNode1=function(){return this.getLengthTo(this.node1)},f.prototype.getLengthToNode2=function(){return this.getLengthTo(this.node2)},f.prototype.getCoef1=function(e){return this.getCoef(this.node1,e)},f.prototype.getCoef2=function(e){return this.getCoef(this.node2,e)},f.prototype.getCoef=function(e,t){var o=this.getVector(t),r=o.length();o.normalize();var a=e.getOriginalPosition(),i=a.sub(t.getOriginalPosition()),s=o.dot(i),n=_(i.lengthSq()-s*s);return 0>=n&&(console.warn("bad moment arm"),n=.001),1-s/r},f.prototype.getLengthTo=function(e){var t=this.getVector().normalize(),o=e.getOriginalPosition(),r=o.sub(this.edge.nodes[1].getOriginalPosition()),a=t.dot(r),i=_(r.lengthSq()-a*a);return 0>=i&&(console.warn("bad moment arm"),i=.001),i},f.prototype.getNodeIndex=function(e){return e===this.node1?1:e===this.node2?2:e===this.edge.nodes[0]?3:e===this.edge.nodes[1]?4:(console.log("unknown node type"),0)},f.prototype.setVisibility=function(){var e=!1;e=0===this.type?this.globals.panelsVisible:0<this.targetTheta&&this.globals.mtnsVisible||0>this.targetTheta&&this.globals.valleysVisible,this.edge.setVisibility(e)},f.prototype.destroy=function(){if(this.node1.removeCrease(this),this.node2.removeCrease(this),this.edge&&this.edge.nodes)for(var e=0;e<this.edge.nodes.length;e+=1)this.edge.nodes[e].removeInvCrease(this);this.edge=null,this.face1Index=null,this.face2Index=null,this.targetTheta=null,this.type=null,this.node1=null,this.node2=null,this.index=null};var w=P.THREE||require("three"),z=P.THREE||require("three"),O=P.earcut||require("earcut"),R=P.FOLD||require("fold"),k=z.SVGLoader||require("three-svg-loader"),G=function(e){if(null==e)return{};var t=Object.keys(y),o={};return Object.keys(e).filter(function(e){return t.includes(e)}).forEach(function(t){o[t]=e[t]}),o};return function(e){var t=Object.assign(JSON.parse(JSON.stringify(y)),G(e));null==t.append&&(t.append=P.document.body),t.threeView=n(t),t.UI3D=c(t),t.model=h(t),t.gpuMath=d(),t.dynamicSolver=g(t),t.pattern=p(t);var o=function(){t.touchMode="rotate",t.threeView.enableCameraRotate(!0),t.UI3D.hideHighlighters()},r=function(){t.touchMode="grab",t.threeView.enableCameraRotate(!1),t.threeView.resetModel()};return Object.defineProperty(t,"loadFOLD",{value:function(e){return t.threeView.resetModel(),t.pattern.setFoldData(e)}}),Object.defineProperty(t,"loadSVG",{value:function(e){return t.threeView.resetModel(),t.pattern.loadSVG(e)}}),Object.defineProperty(t,"loadSVGString",{value:function(e){t.threeView.resetModel();var o=new DOMParser().parseFromString(e,"text/xml").childNodes[0];return t.pattern.loadSVG(o)}}),Object.defineProperty(t,"warn",{value:function(e){return console.warn(e)}}),Object.defineProperty(t,"noCreasePatternAvailable",{value:function(){return"fold"===t.extension}}),Object.defineProperty(t,"grab",{set:function(e){return e?r():o()},get:function(){return"grab"===t.touchMode}}),Object.defineProperty(t,"foldPercent",{set:function(e){t.creasePercent=e,t.shouldChangeCreasePercent=!0},get:function(){return t.creasePercent}}),Object.defineProperty(t,"strain",{set:function(e){t.colorMode=e?"axialStrain":"color",t.model.setMeshMaterial()},get:function(){return"axialStrain"===t.colorMode}}),t}});
